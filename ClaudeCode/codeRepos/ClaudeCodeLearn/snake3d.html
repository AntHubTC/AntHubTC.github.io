<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D åˆ›æ„è´ªåƒè›‡ - Neon Snake</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* UI è¦†ç›–å±‚ */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* åˆ†æ•°æ˜¾ç¤º */
        #score-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-size: 24px;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            z-index: 100;
        }

        #score-panel .label {
            font-size: 14px;
            opacity: 0.7;
        }

        #score-panel .value {
            font-size: 36px;
            font-weight: bold;
        }

        /* æ§åˆ¶æç¤º */
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            text-align: center;
        }

        /* æ¸¸æˆå¼€å§‹/ç»“æŸç•Œé¢ */
        #game-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            z-index: 200;
        }

        #game-menu h1 {
            font-size: 60px;
            color: #fff;
            text-shadow:
                0 0 10px #f0f,
                0 0 20px #f0f,
                0 0 40px #f0f,
                0 0 80px #f0f;
            margin-bottom: 20px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f, 0 0 40px #f0f; }
            to { text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 80px #0ff; }
        }

        #game-menu .subtitle {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 40px;
        }

        .btn {
            background: transparent;
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 50px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff;
        }

        #final-score {
            font-size: 48px;
            color: #f0f;
            text-shadow: 0 0 20px #f0f;
            margin: 20px 0;
        }

        /* èƒ½åŠ›æç¤º */
        #power-up-indicator {
            position: absolute;
            top: 100px;
            left: 20px;
            color: #ff0;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #power-up-indicator.active {
            opacity: 1;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* è¿å‡»æ˜¾ç¤º */
        #combo-display {
            position: absolute;
            top: 50%;
            right: 50px;
            transform: translateY(-50%);
            font-size: 80px;
            font-weight: bold;
            color: #f0f;
            text-shadow: 0 0 30px #f0f;
            opacity: 0;
            transition: all 0.3s;
        }

        #combo-display.show {
            opacity: 1;
            animation: comboAnim 0.5s ease-out;
        }

        @keyframes comboAnim {
            0% { transform: translateY(-50%) scale(0.5); }
            50% { transform: translateY(-50%) scale(1.2); }
            100% { transform: translateY(-50%) scale(1); }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="score-panel">
                <div class="label">åˆ†æ•°</div>
                <div class="value" id="score">0</div>
                <div class="label" style="margin-top: 10px;">æœ€é«˜åˆ†</div>
                <div class="value" id="high-score" style="font-size: 24px; color: #f0f;">0</div>
            </div>

            <div id="power-up-indicator">
                âš¡ <span id="power-up-text">åŠ é€Ÿä¸­!</span>
            </div>

            <div id="combo-display">x<span id="combo-value">2</span></div>

            <div id="controls-hint">
                A/â† å·¦è½¬ | D/â†’ å³è½¬ | â†‘ ä¸Šä»° | â†“ ä¸‹ä¿¯ | ç©ºæ ¼ åŠ é€Ÿ | R é‡æ–°å¼€å§‹
            </div>

            <div id="game-menu">
                <h1>éœ“è™¹è›‡</h1>
                <p class="subtitle">3D åˆ›æ„è´ªåƒè›‡</p>
                <div id="start-screen">
                    <button class="btn" id="start-btn">å¼€å§‹æ¸¸æˆ</button>
                </div>
                <div id="game-over-screen" class="hidden">
                    <p style="color: #f66; font-size: 24px;">æ¸¸æˆç»“æŸ</p>
                    <div id="final-score">0</div>
                    <button class="btn" id="restart-btn">å†æ¥ä¸€æ¬¡</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== æ¸¸æˆé…ç½® ====================
        const CONFIG = {
            gridSize: 20,           // ç½‘æ ¼å¤§å°
            cellSize: 1,            // å•å…ƒæ ¼å¤§å°
            moveSpeed: 5,           // ç§»åŠ¨é€Ÿåº¦ï¼ˆå•ä½/ç§’ï¼‰
            maxSpeed: 10,           // æœ€å¤§é€Ÿåº¦
            speedIncrement: 0.1,    // æ¯æ¬¡åŠ é€Ÿå¹…åº¦
            boostMultiplier: 2,     // åŠ é€Ÿå€æ•°
            bodySegmentDistance: 0.8, // è›‡èº«æ®µä¹‹é—´çš„è·ç¦»
            foodTypes: {
                normal: { color: 0x00ff00, points: 10, glow: 0.5 },
                golden: { color: 0xffd700, points: 50, glow: 1.0 },
                rainbow: { color: 0xff00ff, points: 30, glow: 0.8, special: 'rainbow' },
                shrink: { color: 0x00ffff, points: 20, glow: 0.6, special: 'shrink' }
            }
        };

        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameState = {
            running: false,
            paused: false,
            score: 0,
            highScore: parseInt(localStorage.getItem('snake3d_highscore') || '0'),
            speed: CONFIG.moveSpeed,
            combo: 0,
            lastEatTime: 0,
            boosting: false,
            lastTime: 0
        };

        // ==================== Three.js åˆå§‹åŒ– ====================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000000);
        document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('ui-overlay'));

        // ç›¸æœºä½ç½®
        camera.position.set(0, 25, 25);
        camera.lookAt(0, 0, 0);

        // ==================== ç¯å…‰è®¾ç½® ====================
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(10, 20, 10);
        scene.add(pointLight);

        // éœ“è™¹ç¯æ•ˆæœ
        const neonLights = [];
        const neonColors = [0xff00ff, 0x00ffff, 0xff0066, 0x00ff66];
        neonColors.forEach((color, i) => {
            const light = new THREE.PointLight(color, 0.5, 30);
            const angle = (i / neonColors.length) * Math.PI * 2;
            light.position.set(
                Math.cos(angle) * 15,
                5,
                Math.sin(angle) * 15
            );
            scene.add(light);
            neonLights.push(light);
        });

        // è·Ÿéšè›‡å¤´çš„èšå…‰ç¯ï¼ˆç”¨äºç…§äº®å‰æ–¹ï¼‰
        const headLight = new THREE.SpotLight(0xffffff, 1.5, 30, Math.PI / 4, 0.5);
        headLight.position.set(0, 5, 0);
        scene.add(headLight);
        scene.add(headLight.target);

        // ==================== åˆ›å»ºæ¸¸æˆåœºåœ° ====================
        function createArena() {
            // åœ°é¢ç½‘æ ¼
            const gridHelper = new THREE.GridHelper(CONFIG.gridSize, CONFIG.gridSize, 0x444444, 0x222222);
            scene.add(gridHelper);

            // å‘å…‰åœ°é¢
            const groundGeo = new THREE.PlaneGeometry(CONFIG.gridSize, CONFIG.gridSize);
            const groundMat = new THREE.MeshBasicMaterial({
                color: 0x111122,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            scene.add(ground);

            // è¾¹ç•Œå¢™ï¼ˆå‘å…‰æ•ˆæœï¼‰
            const wallMaterial = new THREE.MeshBasicMaterial({
                color: 0x0066ff,
                transparent: true,
                opacity: 0.3
            });

            const wallHeight = 10;
            const halfSize = CONFIG.gridSize / 2;

            // å››é¢å¢™
            const walls = [
                { pos: [halfSize, wallHeight/2, 0], rot: [0, 0, 0], scale: [0.1, wallHeight, CONFIG.gridSize] },
                { pos: [-halfSize, wallHeight/2, 0], rot: [0, 0, 0], scale: [0.1, wallHeight, CONFIG.gridSize] },
                { pos: [0, wallHeight/2, halfSize], rot: [0, 0, 0], scale: [CONFIG.gridSize, wallHeight, 0.1] },
                { pos: [0, wallHeight/2, -halfSize], rot: [0, 0, 0], scale: [CONFIG.gridSize, wallHeight, 0.1] }
            ];

            walls.forEach(w => {
                const geo = new THREE.BoxGeometry(1, 1, 1);
                const wall = new THREE.Mesh(geo, wallMaterial);
                wall.position.set(...w.pos);
                wall.scale.set(...w.scale);
                scene.add(wall);
            });

            // å¤©èŠ±æ¿ç½‘æ ¼ï¼ˆå¯é€‰ï¼Œè¡¨ç¤ºé«˜åº¦é™åˆ¶ï¼‰
            const ceilingGrid = new THREE.GridHelper(CONFIG.gridSize, CONFIG.gridSize, 0x222244, 0x111122);
            ceilingGrid.position.y = wallHeight;
            scene.add(ceilingGrid);
        }

        // ==================== è›‡ç±»ï¼ˆå¹³æ»‘ç§»åŠ¨ç‰ˆæœ¬ï¼‰ ====================
        class Snake {
            constructor() {
                this.positions = []; // è›‡èº«ä½ç½®ï¼ˆè¿ç»­åæ ‡ï¼‰
                this.direction = new THREE.Vector3(1, 0, 0);
                this.targetDirection = new THREE.Vector3(1, 0, 0);
                this.lastHorizontalDir = new THREE.Vector3(1, 0, 0);
                this.meshes = [];
                this.trailParticles = [];
                this.headGlow = null;
                this.pathHistory = []; // è·¯å¾„å†å²ï¼Œç”¨äºè›‡èº«è·Ÿéš
                this.segmentCount = 3;
            }

            init() {
                // æ¸…é™¤æ—§çš„
                this.meshes.forEach(m => scene.remove(m));
                this.meshes = [];
                this.positions = [];
                this.pathHistory = [];
                this.trailParticles.forEach(p => scene.remove(p));
                this.trailParticles = [];
                if (this.headGlow) scene.remove(this.headGlow);

                // åˆå§‹åŒ–è›‡å¤´ä½ç½®
                this.positions.push(new THREE.Vector3(0, 0.5, 0));

                // åˆå§‹åŒ–è›‡èº«ä½ç½®
                for (let i = 1; i < this.segmentCount; i++) {
                    this.positions.push(new THREE.Vector3(-i * CONFIG.bodySegmentDistance, 0.5, 0));
                }

                // åˆå§‹åŒ–è·¯å¾„å†å²
                for (let i = 0; i < 500; i++) {
                    this.pathHistory.push(new THREE.Vector3(-i * 0.05, 0.5, 0));
                }

                this.direction.set(1, 0, 0);
                this.targetDirection.set(1, 0, 0);
                this.lastHorizontalDir.set(1, 0, 0);
                this.segmentCount = 3;
                this.createMeshes();
            }

            createMeshes() {
                // æ¸…é™¤æ—§mesh
                this.meshes.forEach(m => scene.remove(m));
                this.meshes = [];
                if (this.headGlow) scene.remove(this.headGlow);

                for (let i = 0; i < this.positions.length; i++) {
                    const isHead = i === 0;
                    const size = isHead ? 0.9 : Math.max(0.7 - i * 0.03, 0.3);
                    const geo = isHead
                        ? new THREE.SphereGeometry(size / 2, 16, 16)
                        : new THREE.SphereGeometry(size / 2, 12, 12);

                    const hue = (i / Math.max(this.positions.length, 1)) * 0.3;
                    const color = new THREE.Color().setHSL(0.8 - hue, 1, 0.5);

                    const mat = new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: isHead ? 0.5 : 0.2,
                        shininess: 100
                    });

                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.copy(this.positions[i]);
                    scene.add(mesh);
                    this.meshes.push(mesh);

                    if (isHead) {
                        const glowGeo = new THREE.SphereGeometry(0.6, 16, 16);
                        const glowMat = new THREE.MeshBasicMaterial({
                            color: 0xff00ff,
                            transparent: true,
                            opacity: 0.3
                        });
                        this.headGlow = new THREE.Mesh(glowGeo, glowMat);
                        this.headGlow.position.copy(this.positions[i]);
                        scene.add(this.headGlow);
                    }
                }
            }

            // ç›¸å¯¹æ–¹å‘è½¬å‘
            turnLeft() {
                // ä½¿ç”¨è®°ä½çš„æ°´å¹³æ–¹å‘æ¥è®¡ç®—å·¦è½¬
                const dir = this.lastHorizontalDir.clone();
                this.targetDirection.set(dir.z, 0, -dir.x).normalize();
            }

            turnRight() {
                // ä½¿ç”¨è®°ä½çš„æ°´å¹³æ–¹å‘æ¥è®¡ç®—å³è½¬
                const dir = this.lastHorizontalDir.clone();
                this.targetDirection.set(-dir.z, 0, dir.x).normalize();
            }

            turnUp() {
                // ä¸Šä»°
                if (this.targetDirection.y <= 0) {
                    this.targetDirection.set(0, 1, 0);
                }
            }

            turnDown() {
                // ä¸‹ä¿¯
                if (this.targetDirection.y >= 0) {
                    this.targetDirection.set(0, -1, 0);
                }
            }

            // å¹³æ»‘ç§»åŠ¨æ›´æ–°ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
            update(deltaTime) {
                // å¹³æ»‘è½¬å‘
                this.direction.lerp(this.targetDirection, 0.15).normalize();

                // è®°ä½æ°´å¹³æ–¹å‘
                if (Math.abs(this.direction.y) < 0.5) {
                    this.lastHorizontalDir.set(this.direction.x, 0, this.direction.z).normalize();
                }

                // è®¡ç®—ç§»åŠ¨è·ç¦»
                const speed = gameState.boosting ? gameState.speed * CONFIG.boostMultiplier : gameState.speed;
                const moveDistance = speed * deltaTime;

                // ç§»åŠ¨è›‡å¤´
                const head = this.positions[0];
                const newHead = head.clone().add(this.direction.clone().multiplyScalar(moveDistance));

                // è¾¹ç•Œå¤„ç†ï¼ˆç©¿è¶Šï¼‰
                const half = CONFIG.gridSize / 2 - 0.5;
                if (newHead.x > half) newHead.x = -half;
                if (newHead.x < -half) newHead.x = half;
                if (newHead.z > half) newHead.z = -half;
                if (newHead.z < -half) newHead.z = half;
                if (newHead.y < 0.5) newHead.y = 0.5;
                if (newHead.y > 9.5) newHead.y = 9.5;

                this.positions[0].copy(newHead);

                // æ·»åŠ åˆ°è·¯å¾„å†å²
                this.pathHistory.unshift(newHead.clone());
                if (this.pathHistory.length > 1000) {
                    this.pathHistory.pop();
                }

                // è›‡èº«è·Ÿéšï¼ˆæ²¿è·¯å¾„ç§»åŠ¨ï¼‰
                for (let i = 1; i < this.positions.length; i++) {
                    const targetIndex = Math.floor(i * CONFIG.bodySegmentDistance / moveDistance);
                    if (targetIndex < this.pathHistory.length) {
                        this.positions[i].lerp(this.pathHistory[Math.min(targetIndex, this.pathHistory.length - 1)], 0.3);
                    }
                }

                this.updateMeshes();
            }

            updateMeshes() {
                for (let i = 0; i < this.positions.length; i++) {
                    if (this.meshes[i]) {
                        this.meshes[i].position.copy(this.positions[i]);

                        // è›‡èº«æ³¢åŠ¨æ•ˆæœ
                        const wave = Math.sin(Date.now() * 0.005 + i * 0.5) * 0.03;
                        this.meshes[i].rotation.z = wave;
                    }
                }

                if (this.headGlow) {
                    this.headGlow.position.copy(this.positions[0]);
                    this.headGlow.scale.setScalar(1 + Math.sin(Date.now() * 0.01) * 0.2);
                }
            }

            grow() {
                // æ·»åŠ æ–°çš„èº«ä½“æ®µ
                const lastPos = this.positions[this.positions.length - 1].clone();
                this.positions.push(lastPos);
                this.segmentCount++;

                // åˆ›å»ºæ–°çš„mesh
                const index = this.positions.length - 1;
                const size = Math.max(0.7 - index * 0.03, 0.3);
                const geo = new THREE.SphereGeometry(size / 2, 12, 12);
                const hue = (index / this.positions.length) * 0.3;
                const color = new THREE.Color().setHSL(0.8 - hue, 1, 0.5);
                const mat = new THREE.MeshPhongMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.2,
                    shininess: 100
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(lastPos);
                scene.add(mesh);
                this.meshes.push(mesh);
            }

            shrink(amount = 2) {
                for (let i = 0; i < amount && this.positions.length > 3; i++) {
                    this.positions.pop();
                    this.segmentCount--;
                    const mesh = this.meshes.pop();
                    if (mesh) scene.remove(mesh);
                }
            }

            createTrailParticle(pos) {
                const geo = new THREE.SphereGeometry(0.08, 6, 6);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.4
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(pos);
                particle.userData.life = 1;
                scene.add(particle);
                this.trailParticles.push(particle);
            }

            updateTrailParticles() {
                // å¶å°”åˆ›å»ºå°¾è¿¹ç²’å­
                if (Math.random() < 0.3 && this.positions.length > 0) {
                    const tail = this.positions[this.positions.length - 1];
                    this.createTrailParticle(tail.clone());
                }

                this.trailParticles = this.trailParticles.filter(p => {
                    p.userData.life -= 0.03;
                    p.material.opacity = p.userData.life * 0.4;
                    p.scale.multiplyScalar(0.97);

                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        return false;
                    }
                    return true;
                });
            }

            checkSelfCollision() {
                if (this.positions.length < 5) return false;
                const head = this.positions[0];
                for (let i = 4; i < this.positions.length; i++) {
                    if (head.distanceTo(this.positions[i]) < 0.4) {
                        return true;
                    }
                }
                return false;
            }

            getHead() {
                return this.positions[0];
            }

            getHeadRotation() {
                return Math.atan2(this.direction.x, this.direction.z);
            }
        }

        // ==================== é£Ÿç‰©ç±» ====================
        class Food {
            constructor() {
                this.items = [];
            }

            spawn(type = 'normal') {
                const half = CONFIG.gridSize / 2 - 1;
                const pos = new THREE.Vector3(
                    Math.floor(Math.random() * CONFIG.gridSize) - half,
                    0.5 + Math.floor(Math.random() * 5),
                    Math.floor(Math.random() * CONFIG.gridSize) - half
                );

                const foodConfig = CONFIG.foodTypes[type];

                // ä¸»ä½“
                const geo = type === 'golden'
                    ? new THREE.OctahedronGeometry(0.4)
                    : new THREE.SphereGeometry(0.3, 16, 16);

                const mat = new THREE.MeshPhongMaterial({
                    color: foodConfig.color,
                    emissive: foodConfig.color,
                    emissiveIntensity: foodConfig.glow,
                    shininess: 150
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                scene.add(mesh);

                // å¤–å‘å…‰
                const glowGeo = new THREE.SphereGeometry(0.5, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: foodConfig.color,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.copy(pos);
                scene.add(glow);

                const food = {
                    mesh,
                    glow,
                    type,
                    config: foodConfig,
                    position: pos
                };

                this.items.push(food);
                return food;
            }

            update() {
                this.items.forEach(food => {
                    // æ—‹è½¬åŠ¨ç”»
                    food.mesh.rotation.y += 0.02;
                    food.mesh.rotation.x += 0.01;

                    // ä¸Šä¸‹æµ®åŠ¨
                    food.mesh.position.y = food.position.y + Math.sin(Date.now() * 0.003) * 0.2;
                    food.glow.position.y = food.mesh.position.y;

                    // è„‰å†²æ•ˆæœ
                    const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                    food.glow.scale.setScalar(pulse);

                    // å½©è™¹é£Ÿç‰©å˜è‰²
                    if (food.type === 'rainbow') {
                        const hue = (Date.now() * 0.001) % 1;
                        food.mesh.material.color.setHSL(hue, 1, 0.5);
                        food.mesh.material.emissive.setHSL(hue, 1, 0.5);
                        food.glow.material.color.setHSL(hue, 1, 0.5);
                    }
                });
            }

            checkCollision(head) {
                for (let i = 0; i < this.items.length; i++) {
                    if (head.distanceTo(this.items[i].position) < 1) {
                        return this.items.splice(i, 1)[0];
                    }
                }
                return null;
            }

            remove(food) {
                scene.remove(food.mesh);
                scene.remove(food.glow);
            }

            clear() {
                this.items.forEach(food => {
                    scene.remove(food.mesh);
                    scene.remove(food.glow);
                });
                this.items = [];
            }
        }

        // ==================== ç²’å­æ•ˆæœ ====================
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            explode(position, color, count = 20) {
                for (let i = 0; i < count; i++) {
                    const geo = new THREE.SphereGeometry(0.1, 4, 4);
                    const mat = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1
                    });
                    const particle = new THREE.Mesh(geo, mat);
                    particle.position.copy(position);

                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.3,
                            (Math.random() - 0.5) * 0.5
                        ),
                        life: 1
                    };

                    scene.add(particle);
                    this.particles.push(particle);
                }
            }

            update() {
                this.particles = this.particles.filter(p => {
                    p.position.add(p.userData.velocity);
                    p.userData.velocity.y -= 0.01; // é‡åŠ›
                    p.userData.life -= 0.02;
                    p.material.opacity = p.userData.life;
                    p.scale.multiplyScalar(0.98);

                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        return false;
                    }
                    return true;
                });
            }
        }

        // ==================== æ¸¸æˆå®ä¾‹ ====================
        const snake = new Snake();
        const food = new Food();
        const particles = new ParticleSystem();
        let gameLoop = null;

        // ==================== æ¸¸æˆæ§åˆ¶ ====================
        function startGame() {
            gameState = {
                ...gameState,
                running: true,
                paused: false,
                score: 0,
                speed: CONFIG.moveSpeed,
                combo: 0,
                lastEatTime: 0,
                boosting: false,
                lastTime: performance.now()
            };

            document.getElementById('game-menu').classList.add('hidden');
            document.getElementById('score').textContent = '0';

            // åˆå§‹åŒ–
            snake.init();
            food.clear();

            // ç”Ÿæˆåˆå§‹é£Ÿç‰©
            food.spawn('normal');
            food.spawn('normal');
        }

        function gameOver() {
            gameState.running = false;

            // æ›´æ–°æœ€é«˜åˆ†
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('snake3d_highscore', gameState.highScore.toString());
            }

            document.getElementById('high-score').textContent = gameState.highScore;
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('game-menu').classList.remove('hidden');

            // æ­»äº¡ç‰¹æ•ˆ
            particles.explode(snake.getHead(), 0xff0000, 50);
        }

        function gameUpdate(deltaTime) {
            if (!gameState.running || gameState.paused) return;

            // æ›´æ–°è›‡çš„ä½ç½®
            snake.update(deltaTime);

            // è‡ªç¢°æ’æ£€æµ‹
            if (snake.checkSelfCollision()) {
                gameOver();
                return;
            }

            // é£Ÿç‰©ç¢°æ’æ£€æµ‹
            const head = snake.getHead();
            const eaten = food.checkCollision(head);
            if (eaten) {
                handleFoodEaten(eaten);
            }

            // ä¿æŒé£Ÿç‰©æ•°é‡
            while (food.items.length < 3) {
                const types = ['normal', 'normal', 'normal', 'golden', 'rainbow', 'shrink'];
                const type = types[Math.floor(Math.random() * types.length)];
                food.spawn(type);
            }
        }

        function handleFoodEaten(eaten) {
            // è®¡ç®—è¿å‡»
            const now = Date.now();
            if (now - gameState.lastEatTime < 2000) {
                gameState.combo++;
            } else {
                gameState.combo = 1;
            }
            gameState.lastEatTime = now;

            // è®¡ç®—åˆ†æ•°
            const comboMultiplier = Math.min(gameState.combo, 10);
            const points = eaten.config.points * comboMultiplier;
            gameState.score += points;

            // æ›´æ–°UI
            document.getElementById('score').textContent = gameState.score;

            // æ˜¾ç¤ºè¿å‡»
            if (gameState.combo > 1) {
                document.getElementById('combo-value').textContent = gameState.combo;
                document.getElementById('combo-display').classList.add('show');
                setTimeout(() => {
                    document.getElementById('combo-display').classList.remove('show');
                }, 500);
            }

            // ç²’å­æ•ˆæœ
            particles.explode(eaten.position, eaten.config.color, 30);

            // ç‰¹æ®Šæ•ˆæœ
            if (eaten.config.special === 'shrink') {
                snake.shrink(2);
            } else if (eaten.config.special === 'rainbow') {
                // å½©è™¹æ•ˆæœ - ä¸´æ—¶åŠ é€Ÿ
                gameState.speed = Math.min(gameState.speed + 1, CONFIG.maxSpeed);
            } else {
                snake.grow();
            }

            // ç§»é™¤é£Ÿç‰©
            food.remove(eaten);

            // é€æ¸åŠ é€Ÿ
            if (gameState.speed < CONFIG.maxSpeed) {
                gameState.speed += CONFIG.speedIncrement;
            }
        }

        // ==================== è¾“å…¥å¤„ç† ====================
        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (!gameState.running) return;

            switch (e.code) {
                case 'KeyA':
                case 'ArrowLeft':
                    // å·¦è½¬
                    snake.turnLeft();
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    // å³è½¬
                    snake.turnRight();
                    break;
                case 'ArrowUp':
                    // ä¸Šä»°ï¼ˆè¿›å…¥ä¸Šå‡çŠ¶æ€ï¼‰
                    snake.turnUp();
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    // ä¸‹ä¿¯ï¼ˆè¿›å…¥ä¸‹é™çŠ¶æ€ï¼‰
                    snake.turnDown();
                    e.preventDefault();
                    break;
                case 'Space':
                    if (!gameState.boosting) {
                        gameState.boosting = true;
                        document.getElementById('power-up-indicator').classList.add('active');
                        document.getElementById('power-up-text').textContent = 'åŠ é€Ÿä¸­!';
                    }
                    e.preventDefault();
                    break;
                case 'KeyR':
                    if (gameState.running) {
                        gameOver();
                    }
                    startGame();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;

            if (e.code === 'Space' && gameState.boosting) {
                gameState.boosting = false;
                document.getElementById('power-up-indicator').classList.remove('active');
            }
        });

        // ==================== UI äº‹ä»¶ ====================
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', () => {
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
            startGame();
        });

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        // ç›¸æœºè·Ÿéšå‚æ•°ï¼ˆè¿‘è·ç¦»è·Ÿéšï¼Œåªçœ‹åˆ°è›‡å¤´ï¼‰
        const cameraOffset = new THREE.Vector3(0, 1.5, 3); // æ›´è¿‘çš„ç›¸æœºåç§»
        const cameraLookAhead = 8; // ç›¸æœºçœ‹å‘è›‡å¤´å‰æ–¹çš„è·ç¦»
        let currentCameraPos = new THREE.Vector3(0, 25, 25);
        let currentLookAt = new THREE.Vector3(0, 0, 0);
        let lastFrameTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            // è®¡ç®—deltaTime
            const now = performance.now();
            const deltaTime = Math.min((now - lastFrameTime) / 1000, 0.1); // è½¬æ¢ä¸ºç§’ï¼Œé™åˆ¶æœ€å¤§å€¼
            lastFrameTime = now;

            // æ›´æ–°æ¸¸æˆé€»è¾‘
            if (gameState.running) {
                gameUpdate(deltaTime);
            }

            // ç¬¬äºŒäººç§°è·Ÿéšç›¸æœº
            if (gameState.running && snake.positions.length > 0) {
                const head = snake.getHead();
                const dir = snake.direction.clone();
                const horizDir = snake.lastHorizontalDir.clone();

                // è®¡ç®—ç›¸æœºç›®æ ‡ä½ç½®ï¼ˆå§‹ç»ˆåŸºäºæ°´å¹³æ–¹å‘ï¼Œåœ¨è›‡å¤´åæ–¹ï¼‰
                const targetCameraPos = new THREE.Vector3(
                    head.x - horizDir.x * cameraOffset.z,
                    head.y + cameraOffset.y,
                    head.z - horizDir.z * cameraOffset.z
                );

                // è®¡ç®—ç›¸æœºçœ‹å‘çš„ç›®æ ‡ç‚¹ï¼ˆè›‡å¤´å‰æ–¹ï¼‰
                let lookAtTarget;
                if (Math.abs(dir.y) > 0.5) {
                    // å‚ç›´ç§»åŠ¨æ—¶ï¼Œçœ‹å‘è›‡å¤´ä½ç½®ç¨å‰æ–¹
                    lookAtTarget = new THREE.Vector3(
                        head.x + horizDir.x * 2,
                        head.y + dir.y * 3,
                        head.z + horizDir.z * 2
                    );
                } else {
                    // æ°´å¹³ç§»åŠ¨æ—¶ï¼Œçœ‹å‘å‰æ–¹
                    lookAtTarget = new THREE.Vector3(
                        head.x + dir.x * cameraLookAhead,
                        head.y,
                        head.z + dir.z * cameraLookAhead
                    );
                }

                // å¹³æ»‘æ’å€¼ç›¸æœºä½ç½®å’Œæœå‘ï¼ˆæ›´å¿«å“åº”ï¼‰
                currentCameraPos.lerp(targetCameraPos, 0.15);
                currentLookAt.lerp(lookAtTarget, 0.2);

                camera.position.copy(currentCameraPos);
                camera.lookAt(currentLookAt);

                // æ›´æ–°è·Ÿéšç¯å…‰ä½ç½®
                headLight.position.set(head.x, head.y + 2, head.z);
                headLight.target.position.set(
                    head.x + dir.x * 10,
                    head.y + dir.y * 10,
                    head.z + dir.z * 10
                );
            } else if (!gameState.running) {
                // æ¸¸æˆæœªå¼€å§‹æ—¶ï¼Œå±•ç¤ºå…¨æ™¯
                camera.position.set(0, 25, 25);
                camera.lookAt(0, 0, 0);
            }

            // éœ“è™¹ç¯åŠ¨ç”»
            neonLights.forEach((light, i) => {
                light.intensity = 0.5 + Math.sin(Date.now() * 0.003 + i) * 0.3;
            });

            // æ›´æ–°å„ä¸ªç³»ç»Ÿ
            food.update();
            snake.updateTrailParticles();
            particles.update();

            renderer.render(scene, camera);
        }

        // ==================== çª—å£è°ƒæ•´ ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== åˆå§‹åŒ– ====================
        createArena();
        document.getElementById('high-score').textContent = gameState.highScore;
        animate();

        console.log('ğŸ 3D Neon Snake Game Initialized!');
        console.log('Controls: WASD/Arrows = Move, Q/E = Up/Down, Space = Boost, R = Restart');
    </script>
</body>
</html>
