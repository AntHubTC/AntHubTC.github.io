<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D åˆ›æ„è´ªåƒè›‡ - Neon Snake</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* UI è¦†ç›–å±‚ */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* åˆ†æ•°æ˜¾ç¤º - ç»ç’ƒæ‹Ÿæ€æ•ˆæœ */
        #score-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            font-size: 24px;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            z-index: 100;
            background: rgba(0, 20, 40, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px 0 rgba(0, 255, 255, 0.2);
        }

        #score-panel .label {
            font-size: 14px;
            opacity: 0.7;
        }

        #score-panel .value {
            font-size: 36px;
            font-weight: bold;
        }

        /* æ§åˆ¶æç¤º */
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            text-align: center;
        }

        /* æ¸¸æˆå¼€å§‹/ç»“æŸç•Œé¢ - ç»ç’ƒæ‹Ÿæ€æ•ˆæœ */
        #game-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            z-index: 200;
            background: rgba(0, 20, 40, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 0, 255, 0.4);
            border-radius: 30px;
            padding: 60px 80px;
            box-shadow: 0 8px 32px 0 rgba(255, 0, 255, 0.3), inset 0 0 60px rgba(255, 0, 255, 0.1);
        }

        #game-menu h1 {
            font-size: 60px;
            color: #fff;
            text-shadow:
                0 0 10px #f0f,
                0 0 20px #f0f,
                0 0 40px #f0f,
                0 0 80px #f0f;
            margin-bottom: 20px;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px #f0f, 0 0 20px #f0f, 0 0 40px #f0f; }
            to { text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 80px #0ff; }
        }

        #game-menu .subtitle {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 40px;
        }

        .btn {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #0ff;
            color: #0ff;
            padding: 15px 50px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
            border-radius: 50px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            background: rgba(0, 255, 255, 0.3);
            color: #000;
            box-shadow: 0 0 30px #0ff, inset 0 0 20px rgba(0, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        #final-score {
            font-size: 48px;
            color: #f0f;
            text-shadow: 0 0 20px #f0f;
            margin: 20px 0;
        }

        /* èƒ½åŠ›æç¤º - ç»ç’ƒæ‹Ÿæ€æ•ˆæœ */
        #power-up-indicator {
            position: absolute;
            top: 100px;
            left: 20px;
            color: #ff0;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.3s;
            background: rgba(255, 200, 0, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 0, 0.3);
            border-radius: 10px;
            padding: 10px 20px;
            box-shadow: 0 4px 16px 0 rgba(255, 255, 0, 0.2);
        }

        #power-up-indicator.active {
            opacity: 1;
            animation: pulse 0.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* è¿å‡»æ˜¾ç¤º */
        #combo-display {
            position: absolute;
            top: 50%;
            right: 50px;
            transform: translateY(-50%);
            font-size: 80px;
            font-weight: bold;
            color: #f0f;
            text-shadow: 0 0 30px #f0f, 0 0 60px #f0f, 0 0 90px #f0f;
            opacity: 0;
            transition: all 0.3s;
            background: rgba(255, 0, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 0, 255, 0.4);
            border-radius: 20px;
            padding: 20px 40px;
            box-shadow: 0 8px 32px 0 rgba(255, 0, 255, 0.3);
        }

        #combo-display.show {
            opacity: 1;
            animation: comboAnim 0.5s ease-out;
        }

        @keyframes comboAnim {
            0% { transform: translateY(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateY(-50%) scale(1.3); opacity: 1; }
            70% { transform: translateY(-50%) scale(0.9); }
            100% { transform: translateY(-50%) scale(1); opacity: 1; }
        }

        /* åˆ†æ•°æ»šåŠ¨åŠ¨ç”» */
        @keyframes scorePopup {
            0% { transform: scale(1); color: #0ff; }
            50% { transform: scale(1.5); color: #ff0; }
            100% { transform: scale(1); color: #0ff; }
        }

        .score-animate {
            animation: scorePopup 0.3s ease-out;
        }

        .hidden {
            display: none !important;
        }

        /* ç§»åŠ¨ç«¯å“åº”å¼æ ·å¼ */
        @media (max-width: 768px) {
            #game-menu {
                padding: 40px 30px;
                width: 90%;
                max-width: 350px;
            }
            
            #game-menu h1 {
                font-size: 36px;
                margin-bottom: 15px;
            }
            
            #game-menu .subtitle {
                font-size: 14px;
                margin-bottom: 30px;
            }
            
            #final-score {
                font-size: 36px;
                margin: 15px 0;
            }
            
            .btn {
                padding: 12px 30px;
                font-size: 16px;
                letter-spacing: 2px;
            }
            
            #score-panel {
                padding: 15px;
            }
            
            #score-panel .value {
                font-size: 32px;
            }
            
            #controls-hint {
                font-size: 12px;
                padding: 8px 15px;
                display: none;
            }
            
            #virtual-gamepad {
                bottom: 20px;
                left: 20px;
            }
            
            .gamepad-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        /* è™šæ‹Ÿæ‰‹æŸ„æ ·å¼ */
        #virtual-gamepad {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 150;
            display: none;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 10px;
            pointer-events: auto;
        }

        .gamepad-btn {
            width: 60px;
            height: 60px;
            border: 2px solid #0ff;
            border-radius: 8px;
            background: rgba(0, 255, 255, 0.1);
            color: #0ff;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            user-select: none;
            touch-action: none;
        }

        .gamepad-btn:hover,
        .gamepad-btn.active {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px #0ff;
            transform: scale(1.05);
        }

        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-down { grid-column: 2; grid-row: 3; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div id="score-panel">
                <div class="label">åˆ†æ•°</div>
                <div class="value" id="score">0</div>
                <div class="label" style="margin-top: 10px;">æœ€é«˜åˆ†</div>
                <div class="value" id="high-score" style="font-size: 24px; color: #f0f;">0</div>
            </div>

            <div id="power-up-indicator">
                âš¡ <span id="power-up-text">åŠ é€Ÿä¸­!</span>
            </div>

            <div id="combo-display">x<span id="combo-value">2</span></div>

            <!-- è™šæ‹Ÿæ‰‹æŸ„ -->
            <div id="virtual-gamepad">
                <button id="btn-up" class="gamepad-btn">â†‘</button>
                <button id="btn-left" class="gamepad-btn">â†</button>
                <button id="btn-right" class="gamepad-btn">â†’</button>
                <button id="btn-down" class="gamepad-btn">â†“</button>
            </div>

            <div id="controls-hint">
                A/â† å·¦è½¬ | D/â†’ å³è½¬ | â†‘ ä¸Šä»° | â†“ ä¸‹ä¿¯ | ç©ºæ ¼ åŠ é€Ÿ | R é‡æ–°å¼€å§‹
            </div>

            <div id="game-menu">
                <h1>éœ“è™¹è›‡</h1>
                <p class="subtitle">3D åˆ›æ„è´ªåƒè›‡</p>
                <div id="start-screen">
                    <button class="btn" id="start-btn">å¼€å§‹æ¸¸æˆ</button>
                </div>
                <div id="game-over-screen" class="hidden">
                    <p style="color: #f66; font-size: 24px;">æ¸¸æˆç»“æŸ</p>
                    <div id="final-score">0</div>
                    <button class="btn" id="restart-btn">å†æ¥ä¸€æ¬¡</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ==================== æ¸¸æˆé…ç½® ====================
        
        // è®¾å¤‡æ£€æµ‹ - åˆ¤æ–­æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                   (window.innerWidth <= 768 && 'ontouchstart' in window);
        }
        
        // æ ¹æ®è®¾å¤‡ç±»å‹æ˜¾ç¤º/éšè—è™šæ‹Ÿæ‰‹æŸ„
        if (isMobileDevice()) {
            // ç§»åŠ¨è®¾å¤‡ - æ˜¾ç¤ºè™šæ‹Ÿæ‰‹æŸ„
            const gamepad = document.getElementById('virtual-gamepad');
            if (gamepad) {
                gamepad.style.display = 'grid';
            }
        }
        
        const CONFIG = {
            // ä¸–ç•Œå¤§å°
            gridSize: 40,           // æ‰©å¤§åˆ°40x40
            wallHeight: 15,         // å¢åŠ é«˜åº¦
            cellSize: 1,            // å•å…ƒæ ¼å¤§å°
            moveSpeed: 5,           // ç§»åŠ¨é€Ÿåº¦ï¼ˆå•ä½/ç§’ï¼‰
            maxSpeed: 10,           // æœ€å¤§é€Ÿåº¦
            speedIncrement: 0.1,    // æ¯æ¬¡åŠ é€Ÿå¹…åº¦
            boostMultiplier: 2,     // åŠ é€Ÿå€æ•°
            bodySegmentDistance: 0.8, // è›‡èº«æ®µä¹‹é—´çš„è·ç¦»

            // é£Ÿç‰©é…ç½®
            foodTypes: {
                normal: { color: 0x00ff00, points: 10, glow: 0.5 },
                golden: { color: 0xffd700, points: 50, glow: 1.0 },
                rainbow: { color: 0xff00ff, points: 30, glow: 0.8, special: 'rainbow' },
                shrink: { color: 0x00ffff, points: 20, glow: 0.6, special: 'shrink' }
            },

            // é“å…·é…ç½®
            powerUpTypes: {
                shield: { color: 0x0088ff, icon: 'ğŸ›¡ï¸', duration: 5000, glow: 0.7 },
                magnet: { color: 0xffff00, icon: 'ğŸ§²', duration: 8000, glow: 0.7 },
                slowTime: { color: 0xffffff, icon: 'â±ï¸', duration: 6000, glow: 0.7 },
                doubleScore: { color: 0xff8800, icon: 'âš¡', duration: 10000, glow: 0.7 }
            },
            powerUpSpawnChance: 0.08,  // 8%æ¦‚ç‡ç”Ÿæˆé“å…·
            magnetRange: 5,            // ç£é“å¸å¼•èŒƒå›´

            // éšœç¢ç‰©é…ç½®
            initialObstacles: 4,      // åˆå§‹éšœç¢æ•°
            obstacleSpawnInterval: 5, // æ¯5ä¸ªé£Ÿç‰©å¢åŠ éšœç¢
            movingObstacleSpeed: 3,   // ç§»åŠ¨éšœç¢é€Ÿåº¦
            laserRotationSpeed: 1     // æ¿€å…‰æ—‹è½¬é€Ÿåº¦
        };

        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        let gameState = {
            running: false,
            paused: false,
            score: 0,
            highScore: parseInt(localStorage.getItem('snake3d_highscore') || '0'),
            speed: CONFIG.moveSpeed,
            combo: 0,
            lastEatTime: 0,
            boosting: false,
            lastTime: 0,
            foodEaten: 0,           // é£Ÿç‰©è®¡æ•°ï¼ˆç”¨äºéšœç¢ç”Ÿæˆï¼‰
            shieldActive: false,    // æŠ¤ç›¾çŠ¶æ€
            magnetActive: false,    // ç£é“çŠ¶æ€
            slowTimeActive: false,  // æ—¶é—´å‡é€ŸçŠ¶æ€
            doubleScoreActive: false // åŒå€åˆ†æ•°çŠ¶æ€
        };

        // ==================== Three.js åˆå§‹åŒ– ====================
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0x000510);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('ui-overlay'));

        // æ·»åŠ é›¾æ•ˆå¢å¼ºæ·±åº¦æ„Ÿ
        scene.fog = new THREE.FogExp2(0x000510, 0.008);

        // ç›¸æœºä½ç½®
        camera.position.set(0, 25, 25);
        camera.lookAt(0, 0, 0);

        // å…¨å±€æ•ˆæœå˜é‡
        let starField = null;
        let ambientParticles = [];
        let explosionParticles = [];
        let speedLines = [];
        let cameraShake = { intensity: 0, duration: 0 };
        let walls = [];
        let gridHelper = null;
        let ground = null;
        let targetCameraPosition = new THREE.Vector3(0, 25, 25);

        // ==================== ç¯å…‰è®¾ç½® ====================
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(10, 20, 10);
        scene.add(pointLight);

        // éœ“è™¹ç¯æ•ˆæœ
        const neonLights = [];
        const neonColors = [0xff00ff, 0x00ffff, 0xff0066, 0x00ff66];
        neonColors.forEach((color, i) => {
            const light = new THREE.PointLight(color, 0.5, 30);
            const angle = (i / neonColors.length) * Math.PI * 2;
            light.position.set(
                Math.cos(angle) * 15,
                5,
                Math.sin(angle) * 15
            );
            scene.add(light);
            neonLights.push(light);
        });

        // è·Ÿéšè›‡å¤´çš„èšå…‰ç¯ï¼ˆç”¨äºç…§äº®å‰æ–¹ï¼‰
        const headLight = new THREE.SpotLight(0xffffff, 1.5, 30, Math.PI / 4, 0.5);
        headLight.position.set(0, 5, 0);
        headLight.castShadow = true;
        headLight.shadow.mapSize.width = 1024;
        headLight.shadow.mapSize.height = 1024;
        scene.add(headLight);
        scene.add(headLight.target);

        // ==================== æ˜Ÿç©ºèƒŒæ™¯ ====================
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);

            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                positions[i3] = (Math.random() - 0.5) * 200;
                positions[i3 + 1] = Math.random() * 100 + 20;
                positions[i3 + 2] = (Math.random() - 0.5) * 200;

                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.8, 0.8);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;

                sizes[i] = Math.random() * 2 + 0.5;
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const starMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        // ==================== ç¯å¢ƒæ¼‚æµ®ç²’å­ ====================
        function createAmbientParticles() {
            const particleCount = 100;
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 1, 0.7),
                    transparent: true,
                    opacity: 0.6
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(
                    (Math.random() - 0.5) * CONFIG.gridSize,
                    Math.random() * CONFIG.wallHeight,
                    (Math.random() - 0.5) * CONFIG.gridSize
                );
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02
                    ),
                    originalY: particle.position.y
                };
                scene.add(particle);
                ambientParticles.push(particle);
            }
        }

        // ==================== çˆ†ç‚¸ç²’å­æ•ˆæœ ====================
        function createExplosion(position, color, count = 30) {
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.SphereGeometry(0.08, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5,
                        (Math.random() - 0.5) * 0.5
                    ),
                    life: 1.0,
                    decay: Math.random() * 0.02 + 0.02
                };
                scene.add(particle);
                explosionParticles.push(particle);
            }
        }

        // ==================== é€Ÿåº¦çº¿æ•ˆæœ ====================
        function createSpeedLines() {
            const lineCount = 50;
            for (let i = 0; i < lineCount; i++) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(6);
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const material = new THREE.LineBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0
                });
                const line = new THREE.Line(geometry, material);
                line.userData = {
                    speed: Math.random() * 0.3 + 0.2,
                    offset: Math.random() * Math.PI * 2
                };
                scene.add(line);
                speedLines.push(line);
            }
        }

        // ==================== ç›¸æœºéœ‡åŠ¨æ•ˆæœ ====================
        function triggerCameraShake(intensity, duration) {
            cameraShake.intensity = intensity;
            cameraShake.duration = duration;
        }

        // ==================== åˆ›å»ºæ¸¸æˆåœºåœ° ====================
        function createArena() {
            // åœ°é¢ç½‘æ ¼ - åŠ¨æ€é¢œè‰²æ•ˆæœ
            gridHelper = new THREE.GridHelper(CONFIG.gridSize, CONFIG.gridSize, 0x4444ff, 0x222266);
            gridHelper.position.y = 0;
            scene.add(gridHelper);

            // åå°„åœ°é¢
            const groundGeo = new THREE.PlaneGeometry(CONFIG.gridSize, CONFIG.gridSize);
            const groundMat = new THREE.MeshPhongMaterial({
                color: 0x1a1a3a,
                transparent: true,
                opacity: 0.95,
                shininess: 100,
                specular: 0x6666ff,
                reflectivity: 1
            });
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            scene.add(ground);

            // è¾¹ç•Œå¢™ï¼ˆå‘å…‰æ•ˆæœ + è„‰å†²åŠ¨ç”»ï¼‰
            const wallMaterial = new THREE.MeshPhongMaterial({
                color: 0x0066ff,
                emissive: 0x0033aa,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.4,
                shininess: 100
            });

            const halfSize = CONFIG.gridSize / 2;

            // å››é¢å¢™
            walls = [];
            const wallConfigs = [
                { pos: [halfSize, CONFIG.wallHeight/2, 0], rot: [0, 0, 0], scale: [0.1, CONFIG.wallHeight, CONFIG.gridSize] },
                { pos: [-halfSize, CONFIG.wallHeight/2, 0], rot: [0, 0, 0], scale: [0.1, CONFIG.wallHeight, CONFIG.gridSize] },
                { pos: [0, CONFIG.wallHeight/2, halfSize], rot: [0, 0, 0], scale: [CONFIG.gridSize, CONFIG.wallHeight, 0.1] },
                { pos: [0, CONFIG.wallHeight/2, -halfSize], rot: [0, 0, 0], scale: [CONFIG.gridSize, CONFIG.wallHeight, 0.1] }
            ];

            wallConfigs.forEach(w => {
                const geo = new THREE.BoxGeometry(1, 1, 1);
                const wall = new THREE.Mesh(geo, wallMaterial);
                wall.position.set(...w.pos);
                wall.scale.set(...w.scale);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                walls.push(wall);
            });

            // å¤©èŠ±æ¿ç½‘æ ¼
            const ceilingGrid = new THREE.GridHelper(CONFIG.gridSize, CONFIG.gridSize, 0x2222ff, 0x111133);
            ceilingGrid.position.y = CONFIG.wallHeight;
            scene.add(ceilingGrid);
        }

        // ==================== è›‡ç±»ï¼ˆå¹³æ»‘ç§»åŠ¨ç‰ˆæœ¬ï¼‰ ====================
        class Snake {
            constructor() {
                this.positions = []; // è›‡èº«ä½ç½®ï¼ˆè¿ç»­åæ ‡ï¼‰
                this.direction = new THREE.Vector3(1, 0, 0);
                this.targetDirection = new THREE.Vector3(1, 0, 0);
                this.lastHorizontalDir = new THREE.Vector3(1, 0, 0);
                this.meshes = [];
                this.trailParticles = [];
                this.headGlow = null;
                this.eyes = [];
                this.pathHistory = []; // è·¯å¾„å†å²ï¼Œç”¨äºè›‡èº«è·Ÿéš
                this.segmentCount = 3;
            }

            init() {
                // æ¸…é™¤æ—§çš„
                this.meshes.forEach(m => scene.remove(m));
                this.meshes = [];
                this.positions = [];
                this.pathHistory = [];
                this.trailParticles.forEach(p => scene.remove(p));
                this.trailParticles = [];
                if (this.headGlow) scene.remove(this.headGlow);
                this.eyes.forEach(e => scene.remove(e));
                this.eyes = [];

                // åˆå§‹åŒ–è›‡å¤´ä½ç½®
                this.positions.push(new THREE.Vector3(0, 0.5, 0));

                // åˆå§‹åŒ–è›‡èº«ä½ç½®
                for (let i = 1; i < this.segmentCount; i++) {
                    this.positions.push(new THREE.Vector3(-i * CONFIG.bodySegmentDistance, 0.5, 0));
                }

                // åˆå§‹åŒ–è·¯å¾„å†å²
                for (let i = 0; i < 500; i++) {
                    this.pathHistory.push(new THREE.Vector3(-i * 0.05, 0.5, 0));
                }

                this.direction.set(1, 0, 0);
                this.targetDirection.set(1, 0, 0);
                this.lastHorizontalDir.set(1, 0, 0);
                this.segmentCount = 3;
                this.createMeshes();
            }

            createMeshes() {
                // æ¸…é™¤æ—§mesh
                this.meshes.forEach(m => scene.remove(m));
                this.meshes = [];
                if (this.headGlow) scene.remove(this.headGlow);
                this.eyes.forEach(e => scene.remove(e));
                this.eyes = [];

                for (let i = 0; i < this.positions.length; i++) {
                    const isHead = i === 0;
                    const size = isHead ? 0.9 : Math.max(0.7 - i * 0.03, 0.3);
                    const geo = isHead
                        ? new THREE.SphereGeometry(size / 2, 32, 32)
                        : new THREE.SphereGeometry(size / 2, 24, 24);

                    const hue = (i / Math.max(this.positions.length, 1)) * 0.3;
                    const color = new THREE.Color().setHSL(0.8 - hue, 1, 0.5);

                    // æ”¹è¿›çš„æè´¨ - é‡‘å±/ç»ç’ƒè´¨æ„Ÿ
                    const mat = new THREE.MeshPhysicalMaterial({
                        color: color,
                        emissive: color,
                        emissiveIntensity: isHead ? 0.8 : 0.3,
                        metalness: 0.8,
                        roughness: 0.2,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.1,
                        reflectivity: 1.0
                    });

                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.copy(this.positions[i]);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);
                    this.meshes.push(mesh);

                    if (isHead) {
                        // è›‡å¤´å‘å…‰æ•ˆæœ
                        const glowGeo = new THREE.SphereGeometry(0.7, 32, 32);
                        const glowMat = new THREE.MeshBasicMaterial({
                            color: 0xff00ff,
                            transparent: true,
                            opacity: 0.2
                        });
                        this.headGlow = new THREE.Mesh(glowGeo, glowMat);
                        this.headGlow.position.copy(this.positions[i]);
                        scene.add(this.headGlow);

                        // æ·»åŠ çœ¼ç›
                        this.createEyes(this.positions[i]);
                    }
                }
            }

            createEyes(headPosition) {
                const eyeGeo = new THREE.SphereGeometry(0.08, 16, 16);
                const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const pupilGeo = new THREE.SphereGeometry(0.04, 16, 16);
                const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

                // å·¦çœ¼
                const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
                const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
                leftPupil.position.z = 0.06;
                leftEye.add(leftPupil);
                leftEye.position.set(0.15, 0.1, 0.3);
                scene.add(leftEye);
                this.eyes.push(leftEye);

                // å³çœ¼
                const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
                const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
                rightPupil.position.z = 0.06;
                rightEye.add(rightPupil);
                rightEye.position.set(-0.15, 0.1, 0.3);
                scene.add(rightEye);
                this.eyes.push(rightEye);
            }

            // ç›¸å¯¹æ–¹å‘è½¬å‘
            turnLeft() {
                // ä½¿ç”¨è®°ä½çš„æ°´å¹³æ–¹å‘æ¥è®¡ç®—å·¦è½¬
                const dir = this.lastHorizontalDir.clone();
                this.targetDirection.set(dir.z, 0, -dir.x).normalize();
            }

            turnRight() {
                // ä½¿ç”¨è®°ä½çš„æ°´å¹³æ–¹å‘æ¥è®¡ç®—å³è½¬
                const dir = this.lastHorizontalDir.clone();
                this.targetDirection.set(-dir.z, 0, dir.x).normalize();
            }

            turnUp() {
                // ä¸Šä»°
                if (this.targetDirection.y <= 0) {
                    this.targetDirection.set(0, 1, 0);
                }
            }

            turnDown() {
                // ä¸‹ä¿¯
                if (this.targetDirection.y >= 0) {
                    this.targetDirection.set(0, -1, 0);
                }
            }

            // å¹³æ»‘ç§»åŠ¨æ›´æ–°ï¼ˆæ¯å¸§è°ƒç”¨ï¼‰
            update(deltaTime) {
                // å¹³æ»‘è½¬å‘
                this.direction.lerp(this.targetDirection, 0.15).normalize();

                // è®°ä½æ°´å¹³æ–¹å‘
                if (Math.abs(this.direction.y) < 0.5) {
                    this.lastHorizontalDir.set(this.direction.x, 0, this.direction.z).normalize();
                }

                // è®¡ç®—ç§»åŠ¨è·ç¦»
                const speed = gameState.boosting ? gameState.speed * CONFIG.boostMultiplier : gameState.speed;
                const moveDistance = speed * deltaTime;

                // ç§»åŠ¨è›‡å¤´
                const head = this.positions[0];
                const newHead = head.clone().add(this.direction.clone().multiplyScalar(moveDistance));

                // è¾¹ç•Œå¤„ç†ï¼ˆç©¿è¶Šï¼‰
                const half = CONFIG.gridSize / 2 - 0.5;
                if (newHead.x > half) newHead.x = -half;
                if (newHead.x < -half) newHead.x = half;
                if (newHead.z > half) newHead.z = -half;
                if (newHead.z < -half) newHead.z = half;
                if (newHead.y < 0.5) newHead.y = 0.5;
                if (newHead.y > CONFIG.wallHeight - 0.5) newHead.y = CONFIG.wallHeight - 0.5;

                this.positions[0].copy(newHead);

                // æ·»åŠ åˆ°è·¯å¾„å†å²
                this.pathHistory.unshift(newHead.clone());
                if (this.pathHistory.length > 1000) {
                    this.pathHistory.pop();
                }

                // è›‡èº«è·Ÿéšï¼ˆæ²¿è·¯å¾„ç§»åŠ¨ï¼‰
                for (let i = 1; i < this.positions.length; i++) {
                    const targetIndex = Math.floor(i * CONFIG.bodySegmentDistance / moveDistance);
                    if (targetIndex < this.pathHistory.length) {
                        this.positions[i].lerp(this.pathHistory[Math.min(targetIndex, this.pathHistory.length - 1)], 0.3);
                    }
                }

                // æ›´æ–°meshä½ç½®
                for (let i = 0; i < this.positions.length; i++) {
                    this.meshes[i].position.copy(this.positions[i]);

                    // æ·»åŠ æ³¢åŠ¨æ•ˆæœ
                    if (i > 0) {
                        const wave = Math.sin(Date.now() * 0.003 + i * 0.5) * 0.015;
                        this.meshes[i].position.y += wave;
                    }
                }

                // æ›´æ–°å‘å…‰æ•ˆæœ
                if (this.headGlow) {
                    this.headGlow.position.copy(this.positions[0]);
                    const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                    this.headGlow.scale.setScalar(pulse);
                }

                // æ›´æ–°çœ¼ç›ä½ç½®å’Œæœå‘
                this.updateEyes();

                // ç”Ÿæˆæ‹–å°¾ç²’å­
                if (gameState.boosting || Math.random() < 0.3) {
                    this.spawnTrailParticle();
                }

                // æ›´æ–°æ‹–å°¾ç²’å­
                this.updateTrailParticles(deltaTime);
            }

            updateEyes() {
                if (this.eyes.length === 0) return;

                const headPos = this.positions[0];
                const eyeOffset = 0.3;

                // è®¡ç®—çœ¼ç›ä½ç½®
                const rightDir = new THREE.Vector3();
                rightDir.crossVectors(this.direction, new THREE.Vector3(0, 1, 0)).normalize();

                const leftEyePos = headPos.clone().add(rightDir.clone().multiplyScalar(eyeOffset));
                const rightEyePos = headPos.clone().add(rightDir.clone().multiplyScalar(-eyeOffset));

                this.eyes[0].position.copy(leftEyePos);
                this.eyes[1].position.copy(rightEyePos);

                // è®©çœ¼ç›çœ‹å‘ç§»åŠ¨æ–¹å‘
                this.eyes.forEach(eye => {
                    eye.lookAt(headPos.clone().add(this.direction));
                });
            }

            spawnTrailParticle() {
                // ä»å¤šä¸ªè›‡èº«æ®µç”Ÿæˆç²’å­ï¼Œä»å¤´åˆ°å°¾éƒ½æœ‰
                const segmentCount = Math.min(this.positions.length, 10);
                for (let i = 0; i < segmentCount; i++) {
                    const pos = this.positions[i];
                    const geo = new THREE.SphereGeometry(0.05, 8, 8);
                    const hue = (i / this.positions.length) * 0.3 + 0.7;
                    const color = new THREE.Color().setHSL(hue, 1, 0.6);
                    const mat = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.6
                    });
                    const particle = new THREE.Mesh(geo, mat);
                    particle.position.copy(pos);
                    // ç¨å¾®éšæœºåç§»
                    particle.position.x += (Math.random() - 0.5) * 0.1;
                    particle.position.y += (Math.random() - 0.5) * 0.1;
                    particle.position.z += (Math.random() - 0.5) * 0.1;
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.05
                        ),
                        life: 1.0,
                        decay: 0.02 + Math.random() * 0.02
                    };
                    scene.add(particle);
                    this.trailParticles.push(particle);
                }
            }

            updateTrailParticles(deltaTime) {
                for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                    const p = this.trailParticles[i];
                    p.position.add(p.userData.velocity);
                    p.userData.life -= p.userData.decay;
                    p.material.opacity = p.userData.life * 0.8;
                    p.scale.setScalar(p.userData.life);

                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        this.trailParticles.splice(i, 1);
                    }
                }
            }

            updateMeshes() {
                for (let i = 0; i < this.positions.length; i++) {
                    if (this.meshes[i]) {
                        this.meshes[i].position.copy(this.positions[i]);

                        // å‡å°‘æ³¢åŠ¨æ•ˆæœï¼Œé¿å…æŠ–åŠ¨
                        const wave = Math.sin(Date.now() * 0.003 + i * 0.5) * 0.015;
                        this.meshes[i].rotation.z = wave;
                    }
                }

                if (this.headGlow) {
                    this.headGlow.position.copy(this.positions[0]);
                    this.headGlow.scale.setScalar(1 + Math.sin(Date.now() * 0.01) * 0.2);
                }
            }

            grow() {
                // ä»è·¯å¾„å†å²ä¸­è·å–ä¸€ä¸ªæ›´æ—©çš„ä½ç½®ä½œä¸ºæ–°èº«ä½“æ®µ
                const pathIndex = Math.floor(CONFIG.bodySegmentDistance * 2);
                const lastPos = this.pathHistory[Math.min(pathIndex, this.pathHistory.length - 1)].clone();
                this.positions.push(lastPos);
                this.segmentCount++;

                // åˆ›å»ºæ–°çš„mesh - ä½¿ç”¨ç‰©ç†æè´¨
                const index = this.positions.length - 1;
                const size = Math.max(0.7 - index * 0.03, 0.3);
                const geo = new THREE.SphereGeometry(size / 2, 24, 24);
                const hue = (index / this.positions.length) * 0.3;
                const color = new THREE.Color().setHSL(0.8 - hue, 1, 0.5);
                const mat = new THREE.MeshPhysicalMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.3,
                    metalness: 0.8,
                    roughness: 0.2,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1,
                    reflectivity: 1.0
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(lastPos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
                this.meshes.push(mesh);
            }

            shrink(amount = 2) {
                for (let i = 0; i < amount && this.positions.length > 3; i++) {
                    this.positions.pop();
                    this.segmentCount--;
                    const mesh = this.meshes.pop();
                    if (mesh) scene.remove(mesh);
                }
            }

            createTrailParticle(pos) {
                const geo = new THREE.SphereGeometry(0.08, 6, 6);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.4
                });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(pos);
                particle.userData.life = 1;
                scene.add(particle);
                this.trailParticles.push(particle);
            }

            updateTrailParticles() {
                // å¶å°”åˆ›å»ºå°¾è¿¹ç²’å­
                if (Math.random() < 0.3 && this.positions.length > 0) {
                    const tail = this.positions[this.positions.length - 1];
                    this.createTrailParticle(tail.clone());
                }

                this.trailParticles = this.trailParticles.filter(p => {
                    p.userData.life -= 0.03;
                    p.material.opacity = p.userData.life * 0.4;
                    p.scale.multiplyScalar(0.97);

                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        return false;
                    }
                    return true;
                });
            }

            checkSelfCollision() {
                if (this.positions.length < 5) return false;
                const head = this.positions[0];
                for (let i = 4; i < this.positions.length; i++) {
                    if (head.distanceTo(this.positions[i]) < 0.4) {
                        return true;
                    }
                }
                return false;
            }

            getHead() {
                return this.positions[0];
            }

            getHeadRotation() {
                return Math.atan2(this.direction.x, this.direction.z);
            }
        }

        // ==================== é£Ÿç‰©ç±» ====================
        class Food {
            constructor() {
                this.items = [];
            }

            spawn(type = 'normal') {
                const half = CONFIG.gridSize / 2 - 1;
                const pos = new THREE.Vector3(
                    Math.floor(Math.random() * CONFIG.gridSize) - half,
                    0.5 + Math.floor(Math.random() * 5),
                    Math.floor(Math.random() * CONFIG.gridSize) - half
                );

                const foodConfig = CONFIG.foodTypes[type];

                // ä¸»ä½“
                const geo = type === 'golden'
                    ? new THREE.OctahedronGeometry(0.4)
                    : new THREE.SphereGeometry(0.3, 16, 16);

                const mat = new THREE.MeshPhongMaterial({
                    color: foodConfig.color,
                    emissive: foodConfig.color,
                    emissiveIntensity: foodConfig.glow,
                    shininess: 150
                });

                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                scene.add(mesh);

                // å¤–å‘å…‰
                const glowGeo = new THREE.SphereGeometry(0.5, 8, 8);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: foodConfig.color,
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.copy(pos);
                scene.add(glow);

                const food = {
                    mesh,
                    glow,
                    type,
                    config: foodConfig,
                    position: pos
                };

                this.items.push(food);
                return food;
            }

            update() {
                this.items.forEach(food => {
                    // æ—‹è½¬åŠ¨ç”»
                    food.mesh.rotation.y += 0.02;
                    food.mesh.rotation.x += 0.01;

                    // ä¸Šä¸‹æµ®åŠ¨
                    food.mesh.position.y = food.position.y + Math.sin(Date.now() * 0.003) * 0.2;
                    food.glow.position.y = food.mesh.position.y;

                    // è„‰å†²æ•ˆæœ
                    const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                    food.glow.scale.setScalar(pulse);

                    // å½©è™¹é£Ÿç‰©å˜è‰²
                    if (food.type === 'rainbow') {
                        const hue = (Date.now() * 0.001) % 1;
                        food.mesh.material.color.setHSL(hue, 1, 0.5);
                        food.mesh.material.emissive.setHSL(hue, 1, 0.5);
                        food.glow.material.color.setHSL(hue, 1, 0.5);
                    }
                });
            }

            checkCollision(head) {
                for (let i = 0; i < this.items.length; i++) {
                    if (head.distanceTo(this.items[i].position) < 1) {
                        return this.items.splice(i, 1)[0];
                    }
                }
                return null;
            }

            remove(food) {
                scene.remove(food.mesh);
                scene.remove(food.glow);
            }

            clear() {
                this.items.forEach(food => {
                    scene.remove(food.mesh);
                    scene.remove(food.glow);
                });
                this.items = [];
            }
        }

        // ==================== é“å…·ç³»ç»Ÿ ====================
        class PowerUp {
            constructor() {
                this.items = [];
                this.activeEffects = {};
            }

            spawn(type = 'shield') {
                const half = CONFIG.gridSize / 2 - 2;
                const pos = new THREE.Vector3(
                    (Math.random() - 0.5) * CONFIG.gridSize * 0.8,
                    2 + Math.random() * (CONFIG.wallHeight - 4),
                    (Math.random() - 0.5) * CONFIG.gridSize * 0.8
                );

                const config = CONFIG.powerUpTypes[type];

                // ç«‹æ–¹ä½“é€ å‹
                const geo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                const mat = new THREE.MeshPhysicalMaterial({
                    color: config.color,
                    emissive: config.color,
                    emissiveIntensity: config.glow,
                    metalness: 0.9,
                    roughness: 0.1,
                    clearcoat: 1.0
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.castShadow = true;
                scene.add(mesh);

                // å¤–å‘å…‰ - å…‰ç¯æ•ˆæœ
                const glowGeo = new THREE.SphereGeometry(0.8, 16, 16);
                const glowMat = new THREE.MeshBasicMaterial({
                    color: config.color,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.position.copy(pos);
                scene.add(glow);

                // è„‰å†²ç¯
                const ringGeo = new THREE.RingGeometry(0.9, 1.0, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: config.color,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.copy(pos);
                ring.rotation.x = Math.PI / 2;
                scene.add(ring);

                const powerUp = { mesh, glow, ring, type, config, position: pos, spawnTime: Date.now() };
                this.items.push(powerUp);
                return powerUp;
            }

            update() {
                this.items.forEach(pu => {
                    pu.mesh.rotation.x += 0.02;
                    pu.mesh.rotation.y += 0.03;
                    pu.mesh.position.y = pu.position.y + Math.sin(Date.now() * 0.003) * 0.3;
                    pu.glow.position.y = pu.mesh.position.y;
                    pu.ring.position.y = pu.mesh.position.y;

                    // è„‰å†²æ•ˆæœ
                    const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.3;
                    pu.glow.scale.setScalar(pulse);
                    pu.ring.scale.setScalar(pulse);
                    pu.ring.rotation.z += 0.02;

                    // ç¯çš„ç¼©æ”¾åŠ¨ç”»
                    const ringPulse = 1 + Math.sin(Date.now() * 0.003) * 0.2;
                    pu.ring.scale.setScalar(ringPulse);
                });
            }

            checkCollision(head) {
                for (let i = 0; i < this.items.length; i++) {
                    if (head.distanceTo(this.items[i].position) < 1) {
                        return this.items.splice(i, 1)[0];
                    }
                }
                return null;
            }

            activate(type) {
                const config = CONFIG.powerUpTypes[type];
                const endTime = Date.now() + config.duration;

                switch(type) {
                    case 'shield':
                        gameState.shieldActive = true;
                        setTimeout(() => gameState.shieldActive = false, config.duration);
                        break;
                    case 'magnet':
                        gameState.magnetActive = true;
                        setTimeout(() => gameState.magnetActive = false, config.duration);
                        break;
                    case 'slowTime':
                        gameState.slowTimeActive = true;
                        setTimeout(() => gameState.slowTimeActive = false, config.duration);
                        break;
                    case 'doubleScore':
                        gameState.doubleScoreActive = true;
                        setTimeout(() => gameState.doubleScoreActive = false, config.duration);
                        break;
                }
                this.showPowerUpUI(type, config.duration);
            }

            showPowerUpUI(type, duration) {
                const indicator = document.getElementById('power-up-indicator');
                const config = CONFIG.powerUpTypes[type];
                indicator.innerHTML = `${config.icon} <span id="power-up-text">${type}</span>`;
                indicator.classList.add('active');
                setTimeout(() => indicator.classList.remove('active'), duration);
            }

            remove(pu) {
                scene.remove(pu.mesh);
                scene.remove(pu.glow);
                if (pu.ring) scene.remove(pu.ring);
            }

            clear() {
                this.items.forEach(pu => {
                    scene.remove(pu.mesh);
                    scene.remove(pu.glow);
                });
                this.items = [];
            }
        }

        // ==================== éšœç¢ç‰©ç³»ç»Ÿ ====================
        class Obstacle {
            constructor() {
                this.items = [];
            }

            spawnStatic(pos) {
                const geo = new THREE.BoxGeometry(1, 1, 1);
                const mat = new THREE.MeshPhongMaterial({
                    color: 0xff3333,
                    emissive: 0xff3333,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.7
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                scene.add(mesh);

                const obstacle = { mesh, type: 'static', position: pos };
                this.items.push(obstacle);
                return obstacle;
            }

            spawnMoving(start, end) {
                const geo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const mat = new THREE.MeshPhongMaterial({
                    color: 0xff8800,
                    emissive: 0xff8800,
                    emissiveIntensity: 0.4
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(start);
                scene.add(mesh);

                const obstacle = {
                    mesh,
                    type: 'moving',
                    start: start.clone(),
                    end: end.clone(),
                    position: start.clone(),
                    progress: 0,
                    speed: CONFIG.movingObstacleSpeed
                };
                this.items.push(obstacle);
                return obstacle;
            }

            update(deltaTime) {
                this.items.forEach(obs => {
                    if (obs.type === 'moving') {
                        obs.progress += (obs.speed * deltaTime) / obs.start.distanceTo(obs.end);
                        if (obs.progress > 1) obs.progress = 0;

                        obs.position.lerpVectors(obs.start, obs.end, obs.progress);
                        obs.mesh.position.copy(obs.position);
                    }
                });
            }

            checkCollision(head) {
                for (let obs of this.items) {
                    if (head.distanceTo(obs.position) < 1) {
                        return true;
                    }
                }
                return false;
            }

            remove(obs) {
                scene.remove(obs.mesh);
            }

            clear() {
                this.items.forEach(obs => scene.remove(obs.mesh));
                this.items = [];
            }

            initializeGame() {
                // ç”Ÿæˆåˆå§‹éšœç¢
                for (let i = 0; i < CONFIG.initialObstacles; i++) {
                    const half = CONFIG.gridSize / 2 - 2;
                    const pos = new THREE.Vector3(
                        (Math.random() - 0.5) * CONFIG.gridSize * 0.7,
                        Math.random() * 5 + 2,
                        (Math.random() - 0.5) * CONFIG.gridSize * 0.7
                    );
                    this.spawnStatic(pos);
                }
            }
        }

        // ==================== ç²’å­æ•ˆæœ ====================
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            explode(position, color, count = 20) {
                for (let i = 0; i < count; i++) {
                    const geo = new THREE.SphereGeometry(0.1, 4, 4);
                    const mat = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1
                    });
                    const particle = new THREE.Mesh(geo, mat);
                    particle.position.copy(position);

                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            Math.random() * 0.3,
                            (Math.random() - 0.5) * 0.5
                        ),
                        life: 1
                    };

                    scene.add(particle);
                    this.particles.push(particle);
                }
            }

            update() {
                this.particles = this.particles.filter(p => {
                    p.position.add(p.userData.velocity);
                    p.userData.velocity.y -= 0.01; // é‡åŠ›
                    p.userData.life -= 0.02;
                    p.material.opacity = p.userData.life;
                    p.scale.multiplyScalar(0.98);

                    if (p.userData.life <= 0) {
                        scene.remove(p);
                        return false;
                    }
                    return true;
                });
            }
        }

        // ==================== æ¸¸æˆå®ä¾‹ ====================
        const snake = new Snake();
        const food = new Food();
        const powerUp = new PowerUp();
        const obstacle = new Obstacle();
        const particles = new ParticleSystem();
        let gameLoop = null;

        // ==================== æ¸¸æˆæ§åˆ¶ ====================
        function startGame() {
            gameState = {
                ...gameState,
                running: true,
                paused: false,
                score: 0,
                speed: CONFIG.moveSpeed,
                combo: 0,
                lastEatTime: 0,
                boosting: false,
                lastTime: performance.now(),
                foodEaten: 0,
                shieldActive: false,
                magnetActive: false,
                slowTimeActive: false,
                doubleScoreActive: false
            };

            document.getElementById('game-menu').classList.add('hidden');
            document.getElementById('score').textContent = '0';

            // åˆå§‹åŒ–
            snake.init();
            food.clear();
            powerUp.clear();
            obstacle.clear();

            // ç”Ÿæˆåˆå§‹é£Ÿç‰©
            food.spawn('normal');
            food.spawn('normal');

            // ç”Ÿæˆåˆå§‹éšœç¢ç‰©
            obstacle.initializeGame();

            // å¯åŠ¨ç›¸æœºè¿‡æ¸¡åˆ°è›‡è§†è§’
            cameraTransition.active = true;
            cameraTransition.progress = 0;
        }

        function gameOver() {
            gameState.running = false;

            // æ›´æ–°æœ€é«˜åˆ†
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('snake3d_highscore', gameState.highScore.toString());
            }

            document.getElementById('high-score').textContent = gameState.highScore;
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('game-over-screen').classList.remove('hidden');
            document.getElementById('game-menu').classList.remove('hidden');

            // æ­»äº¡ç‰¹æ•ˆ
            particles.explode(snake.getHead(), 0xff0000, 50);
        }

        function gameUpdate(deltaTime) {
            if (!gameState.running || gameState.paused) return;

            // åº”ç”¨æ—¶é—´å‡é€Ÿæ•ˆæœ
            const effectiveDeltaTime = gameState.slowTimeActive ? deltaTime * 0.5 : deltaTime;

            // æ›´æ–°è›‡çš„ä½ç½®
            snake.update(effectiveDeltaTime);

            // è‡ªç¢°æ’æ£€æµ‹
            if (!gameState.shieldActive && snake.checkSelfCollision()) {
                gameOver();
                return;
            }

            // éšœç¢ç‰©ç¢°æ’æ£€æµ‹
            if (!gameState.shieldActive && obstacle.checkCollision(snake.getHead())) {
                gameOver();
                return;
            }

            // æ›´æ–°éšœç¢ç‰©
            obstacle.update(effectiveDeltaTime);

            // é£Ÿç‰©ç¢°æ’æ£€æµ‹
            const head = snake.getHead();
            const eaten = food.checkCollision(head);
            if (eaten) {
                gameState.foodEaten++;
                handleFoodEaten(eaten);
            }

            // é“å…·ç¢°æ’æ£€æµ‹
            const powerUpEaten = powerUp.checkCollision(head);
            if (powerUpEaten) {
                powerUp.activate(powerUpEaten.type);
                powerUp.remove(powerUpEaten);
                particles.explode(powerUpEaten.position, powerUpEaten.config.color, 20);
            }

            // ç£é“æ•ˆæœï¼šå¸å¼•é™„è¿‘é£Ÿç‰©
            if (gameState.magnetActive) {
                food.items.forEach(f => {
                    const dist = head.distanceTo(f.position);
                    if (dist < CONFIG.magnetRange) {
                        f.position.lerp(head, 0.05);
                        f.mesh.position.copy(f.position);
                        f.glow.position.copy(f.position);
                    }
                });
            }

            // ä¿æŒé£Ÿç‰©æ•°é‡
            while (food.items.length < 3) {
                const types = ['normal', 'normal', 'normal', 'golden', 'rainbow', 'shrink'];
                const type = types[Math.floor(Math.random() * types.length)];
                food.spawn(type);
            }

            // éšæœºç”Ÿæˆé“å…·
            if (Math.random() < CONFIG.powerUpSpawnChance && powerUp.items.length < 2) {
                const types = Object.keys(CONFIG.powerUpTypes);
                const type = types[Math.floor(Math.random() * types.length)];
                powerUp.spawn(type);
            }

            // æ ¹æ®è¿›åº¦ç”Ÿæˆéšœç¢ç‰©
            if (gameState.foodEaten % CONFIG.obstacleSpawnInterval === 0 && gameState.foodEaten > 0) {
                const half = CONFIG.gridSize / 2 - 2;
                const pos = new THREE.Vector3(
                    (Math.random() - 0.5) * CONFIG.gridSize * 0.7,
                    Math.random() * 5 + 2,
                    (Math.random() - 0.5) * CONFIG.gridSize * 0.7
                );
                obstacle.spawnStatic(pos);
            }
        }

        function handleFoodEaten(eaten) {
            // è®¡ç®—è¿å‡»
            const now = Date.now();
            if (now - gameState.lastEatTime < 2000) {
                gameState.combo++;
            } else {
                gameState.combo = 1;
            }
            gameState.lastEatTime = now;

            // è®¡ç®—åˆ†æ•°
            const comboMultiplier = Math.min(gameState.combo, 10);
            let points = eaten.config.points * comboMultiplier;

            // åº”ç”¨åŒå€åˆ†æ•°æ•ˆæœ
            if (gameState.doubleScoreActive) {
                points *= 2;
            }
            gameState.score += points;

            // æ›´æ–°UI - æ·»åŠ åˆ†æ•°åŠ¨ç”»
            const scoreElement = document.getElementById('score');
            scoreElement.textContent = gameState.score;
            scoreElement.classList.remove('score-animate');
            void scoreElement.offsetWidth; // è§¦å‘é‡ç»˜
            scoreElement.classList.add('score-animate');

            // æ˜¾ç¤ºè¿å‡»
            if (gameState.combo > 1) {
                document.getElementById('combo-value').textContent = gameState.combo;
                document.getElementById('combo-display').classList.add('show');
                setTimeout(() => {
                    document.getElementById('combo-display').classList.remove('show');
                }, 500);
            }

            // ç²’å­æ•ˆæœ - çˆ†ç‚¸
            createExplosion(eaten.position, eaten.config.color, 40);
            particles.explode(eaten.position, eaten.config.color, 30);

            // ç›¸æœºéœ‡åŠ¨
            triggerCameraShake(0.3, 0.3);

            // ç‰¹æ®Šæ•ˆæœ
            if (eaten.config.special === 'shrink') {
                snake.shrink(2);
            } else if (eaten.config.special === 'rainbow') {
                // å½©è™¹æ•ˆæœ - ä¸´æ—¶åŠ é€Ÿ
                gameState.speed = Math.min(gameState.speed + 1, CONFIG.maxSpeed);
            } else {
                snake.grow();
            }

            // ç§»é™¤é£Ÿç‰©
            food.remove(eaten);

            // é€æ¸åŠ é€Ÿ
            if (gameState.speed < CONFIG.maxSpeed) {
                gameState.speed += CONFIG.speedIncrement;
            }
        }

        // ==================== è¾“å…¥å¤„ç† ====================
        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (!gameState.running) return;

            switch (e.code) {
                case 'KeyA':
                case 'ArrowLeft':
                    // å·¦è½¬
                    snake.turnLeft();
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    // å³è½¬
                    snake.turnRight();
                    break;
                case 'ArrowUp':
                    // ä¸Šä»°ï¼ˆè¿›å…¥ä¸Šå‡çŠ¶æ€ï¼‰
                    snake.turnUp();
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    // ä¸‹ä¿¯ï¼ˆè¿›å…¥ä¸‹é™çŠ¶æ€ï¼‰
                    snake.turnDown();
                    e.preventDefault();
                    break;
                case 'Space':
                    if (!gameState.boosting) {
                        gameState.boosting = true;
                        document.getElementById('power-up-indicator').classList.add('active');
                        document.getElementById('power-up-text').textContent = 'åŠ é€Ÿä¸­!';
                    }
                    e.preventDefault();
                    break;
                case 'KeyR':
                    if (gameState.running) {
                        gameOver();
                    }
                    startGame();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;

            if (e.code === 'Space' && gameState.boosting) {
                gameState.boosting = false;
                document.getElementById('power-up-indicator').classList.remove('active');
            }
        });

        // ==================== UI äº‹ä»¶ ====================
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', () => {
            document.getElementById('game-over-screen').classList.add('hidden');
            document.getElementById('start-screen').classList.remove('hidden');
            startGame();
        });

        // ==================== è™šæ‹Ÿæ‰‹æŸ„äº‹ä»¶ ====================
        const gamepadBtns = {
            'btn-up': () => snake.turnUp(),
            'btn-down': () => snake.turnDown(),
            'btn-left': () => snake.turnLeft(),
            'btn-right': () => snake.turnRight()
        };

        Object.keys(gamepadBtns).forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) {
                // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ï¼‰
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (gameState.running) {
                        gamepadBtns[btnId]();
                        btn.classList.add('active');
                    }
                });
                btn.addEventListener('touchend', () => btn.classList.remove('active'));

                // é¼ æ ‡äº‹ä»¶ï¼ˆPCç«¯ï¼‰
                btn.addEventListener('mousedown', () => {
                    if (gameState.running) {
                        gamepadBtns[btnId]();
                        btn.classList.add('active');
                    }
                });
                btn.addEventListener('mouseup', () => btn.classList.remove('active'));
                btn.addEventListener('mouseleave', () => btn.classList.remove('active'));
            }
        });

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        // ç›¸æœºè·Ÿéšå‚æ•°ï¼ˆè¿‘è·ç¦»è·Ÿéšï¼Œåªçœ‹åˆ°è›‡å¤´ï¼‰
        const cameraOffset = new THREE.Vector3(0, 2, 5); // æ›´è¿œçš„ç›¸æœºåç§»
        const cameraLookAhead = 8; // ç›¸æœºçœ‹å‘è›‡å¤´å‰æ–¹çš„è·ç¦»
        let currentCameraPos = new THREE.Vector3(0, 25, 25);
        let currentLookAt = new THREE.Vector3(0, 0, 0);
        let lastFrameTime = performance.now();
        let cameraTransition = { active: false, progress: 0, duration: 2.0 }; // ç›¸æœºè¿‡æ¸¡çŠ¶æ€

        function animate() {
            requestAnimationFrame(animate);

            // è®¡ç®—deltaTime
            const now = performance.now();
            const deltaTime = Math.min((now - lastFrameTime) / 1000, 0.1); // è½¬æ¢ä¸ºç§’ï¼Œé™åˆ¶æœ€å¤§å€¼
            lastFrameTime = now;

            // æ›´æ–°æ¸¸æˆé€»è¾‘
            if (gameState.running) {
                gameUpdate(deltaTime);
            }

            // ==================== è§†è§‰æ•ˆæœæ›´æ–° ====================

            // ç›¸æœºè¿‡æ¸¡æ•ˆæœ
            if (cameraTransition.active) {
                cameraTransition.progress += deltaTime / cameraTransition.duration;
                if (cameraTransition.progress >= 1) {
                    cameraTransition.progress = 1;
                    cameraTransition.active = false;
                }
            }

            // æ˜Ÿç©ºèƒŒæ™¯æ—‹è½¬
            if (starField) {
                starField.rotation.y += 0.0001;
                starField.rotation.x += 0.00005;
            }

            // ç¯å¢ƒç²’å­æ›´æ–°
            ambientParticles.forEach(p => {
                p.position.add(p.userData.velocity);
                p.position.y = p.userData.originalY + Math.sin(Date.now() * 0.001 + p.position.x) * 0.5;

                // è¾¹ç•Œæ£€æµ‹
                const half = CONFIG.gridSize / 2;
                if (Math.abs(p.position.x) > half) p.userData.velocity.x *= -1;
                if (Math.abs(p.position.z) > half) p.userData.velocity.z *= -1;
            });

            // çˆ†ç‚¸ç²’å­æ›´æ–°
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const p = explosionParticles[i];
                p.position.add(p.userData.velocity);
                p.userData.velocity.y -= 0.01; // é‡åŠ›
                p.userData.life -= p.userData.decay;
                p.material.opacity = p.userData.life;
                p.scale.setScalar(p.userData.life);

                if (p.userData.life <= 0) {
                    scene.remove(p);
                    explosionParticles.splice(i, 1);
                }
            }

            // é€Ÿåº¦çº¿æ•ˆæœ
            if (gameState.boosting) {
                speedLines.forEach(line => {
                    line.material.opacity = Math.min(line.material.opacity + 0.02, 0.6);
                    const speed = line.userData.speed;
                    const offset = line.userData.offset;
                    const time = Date.now() * 0.001;

                    const positions = line.geometry.attributes.position.array;
                    positions[0] = (Math.random() - 0.5) * 50;
                    positions[1] = Math.random() * 30;
                    positions[2] = (Math.random() - 0.5) * 50;
                    positions[3] = positions[0] + Math.sin(time + offset) * 10;
                    positions[4] = positions[1] - speed * 20;
                    positions[5] = positions[2] + Math.cos(time + offset) * 10;

                    line.geometry.attributes.position.needsUpdate = true;
                });
            } else {
                speedLines.forEach(line => {
                    line.material.opacity = Math.max(line.material.opacity - 0.02, 0);
                });
            }

            // è¾¹ç•Œå¢™è„‰å†²æ•ˆæœ
            walls.forEach((wall, i) => {
                const pulse = 0.5 + Math.sin(Date.now() * 0.003 + i * 0.5) * 0.3;
                wall.material.emissiveIntensity = pulse;
            });

            // åœ°é¢ç½‘æ ¼åŠ¨æ€é¢œè‰²
            if (gridHelper) {
                const time = Date.now() * 0.0005;
                const hue = (Math.sin(time) * 0.1 + 0.6) % 1;
                gridHelper.material.color.setHSL(hue, 0.8, 0.5);
            }

            // ç›¸æœºéœ‡åŠ¨
            if (cameraShake.duration > 0) {
                cameraShake.duration -= deltaTime;
                const shakeIntensity = cameraShake.intensity * (cameraShake.duration / 0.5);
                camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                camera.position.y += (Math.random() - 0.5) * shakeIntensity;
                camera.position.z += (Math.random() - 0.5) * shakeIntensity;
            }

            // ç¬¬äºŒäººç§°è·Ÿéšç›¸æœº
            if (gameState.running && snake.positions.length > 0) {
                const head = snake.getHead();
                const dir = snake.direction.clone();
                const horizDir = snake.lastHorizontalDir.clone();

                // è®¡ç®—ç›¸æœºç›®æ ‡ä½ç½®ï¼ˆå§‹ç»ˆåœ¨è›‡å¤´ä¸Šåæ–¹ï¼‰
                const targetCameraPos = new THREE.Vector3(
                    head.x - horizDir.x * cameraOffset.z,
                    head.y + cameraOffset.y,
                    head.z - horizDir.z * cameraOffset.z
                );

                // è®¡ç®—ç›¸æœºçœ‹å‘çš„ç›®æ ‡ç‚¹ï¼ˆè›‡å¤´å‰æ–¹ï¼ŒåŒ…æ‹¬å‚ç›´æ–¹å‘ï¼‰
                const lookAtTarget = new THREE.Vector3(
                    head.x + dir.x * cameraLookAhead,
                    head.y + dir.y * 3,
                    head.z + dir.z * cameraLookAhead
                );

                // ç›¸æœºè¿‡æ¸¡æœŸé—´ä½¿ç”¨ç¼“åŠ¨æ•ˆæœ
                const lerpFactor = cameraTransition.active ? 
                    0.02 * (1 - cameraTransition.progress) + 0.15 * cameraTransition.progress : 
                    0.15;

                // å¹³æ»‘æ’å€¼ç›¸æœºä½ç½®å’Œæœå‘
                currentCameraPos.lerp(targetCameraPos, lerpFactor);
                currentLookAt.lerp(lookAtTarget, lerpFactor);

                camera.position.copy(currentCameraPos);
                camera.lookAt(currentLookAt);

                // æ›´æ–°è·Ÿéšç¯å…‰ä½ç½®
                headLight.position.set(head.x, head.y + 2, head.z);
                headLight.target.position.set(
                    head.x + dir.x * 10,
                    head.y + dir.y * 10,
                    head.z + dir.z * 10
                );
            } else if (!gameState.running) {
                // æ¸¸æˆæœªå¼€å§‹æ—¶ï¼Œå±•ç¤ºå…¨æ™¯
                camera.position.set(0, 25, 25);
                camera.lookAt(0, 0, 0);
            }

            // éœ“è™¹ç¯åŠ¨ç”»
            neonLights.forEach((light, i) => {
                light.intensity = 0.5 + Math.sin(Date.now() * 0.003 + i) * 0.3;
            });

            // æ›´æ–°å„ä¸ªç³»ç»Ÿ
            food.update();
            powerUp.update();
            snake.updateTrailParticles();
            particles.update();

            renderer.render(scene, camera);
        }

        // ==================== çª—å£è°ƒæ•´ ====================
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==================== åˆå§‹åŒ– ====================
        createArena();
        createStarField();
        createAmbientParticles();
        createSpeedLines();
        document.getElementById('high-score').textContent = gameState.highScore;
        animate();

        console.log('ğŸ 3D Neon Snake Game Initialized!');
        console.log('Controls: A/D = Left/Right, â†‘/â†“ = Up/Down, Space = Boost, R = Restart');
    </script>
</body>
</html>
