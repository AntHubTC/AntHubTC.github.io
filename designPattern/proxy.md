# 代理模式(也叫：委托模式)
### **定义：**
> 为其他对象提供一种代理以控制对这个对象的访问。

代理模式也叫做委托模式，它是一项基本设计技巧。许多其他的模式，如状态模式、策略模式、访问者模式本质上是在更特殊的场合采用了委托模式





### **三个基础角色：**
* Subject抽象主题角色
> 抽象主题类可以是抽象类也可以是接口，是一个最普通的业务类型定义，无特殊要求。
* RealSubject具体主题角色
> 也叫做被委托角色、被代理角色。它才是冤大头，是业务逻辑的具体执行者。
* Proxy代理主题角色
> 也叫做委托类、代理类。它负责对真实角色的应用，把所有抽象主题类定义的方法限制委托给真实主题角色实现，并且在真实主题角色处理完毕前后做预处理和善后处理工作。

通用源码，参见 case1。

一个代理类可以代理多个被委托者或被代理者，因此一个代理类具体代理哪个真实主题角色，是由场景类决定的。当然，最简单的情况是一个主题类和一个代理类，这是最简洁的代理模式。在通常情况下，一个接口只需要一个代理类就可以了，具体代理哪个实现类由高层模块来决定，也就是在代理类的构造函数中传递被代理者，

### **优点：**
* 职责清晰
> 真实的角色就是实现实际的业务逻辑，不用关心其非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰。
* 高扩展性
> 具体主题角色是随时都会发生变化的，只要它实现了接口，甭管它如何变化，都逃不脱如来佛的手掌（接口），那我们的代理类完全就可以在不做任何修改的情况下使用。
* 智能化
> 在的动态代理中你就会看到代理的智能化。有兴趣的话也可以看看Struts是如何把表单元素映射到对象上的。


### **普通代理：**
>   普通代理，它的要求就是客户端只能访问代理角色，而不能访问真实角色
参见 case3

### **强制代理：**
>   强制代理在设计模式中比较另类，为什么这么说呢？一般的思维都是通过代理找到真实的角色，但是强制代理却是要“强制”，你必须通过真实角色查找到代理角色，否则你不能访问。甭管你是通过代理类还是通过直接new一个主题角色类，都不能访问，只有通过真实角色指定的代理类才可以访问，也就是说由真实角色管理代理角色。
> 强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色。高层模块只要调用getProxy就可以访问真实角色的所有方法，它根本就不需要产生一个代理出来，代理的管理已经由真实角色自己完成。
参见 case4

代理类也可以有自己的个性，参见 case5。

> 通常的情况下代理的职责并不一定单一，它可以组合其他的真实角色，也可以实现自己的职责，比如计算费用。代理类可以为真实角色预处理消息、过滤消息、消息转发、事后处理消息等功能。当然一个代理类，可以代理多个真实角色，并且真实角色之间可以有耦合关系。


### **动态代理：**
> 动态代理是在实现阶段不用关心代理谁，而在运行阶段
  才指定代理哪一个对象。相对来说，自己写代理类的方式就是静态代理。
> 现在有一个非常流行的名称叫做面向横切面编程，也就是AOP（Aspect Oriented Programming），其核心就是采用了动态代理机制。

动态代理的通用源码请参见 case7。

> 注意 要实现动态代理的首要条件是：被代理类必须实现一个接口，回想一下前面的分析吧。当然了，现在也有很多技术如CGLIB可以实现不需要接口也可以实现动态代理的方式

> 友情提醒，在学习AOP框架时，弄清楚几个名词就成：切面（Aspect）、切入点（JoinPoint）、通知（Advice）、织入（Weave）就足够了，理解了这几个名词，应用时你就可以游刃有余了！