# WebSocket

## WebSocket介绍

### 基础介绍

​		WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向道，比如说，服务器可以在任意时刻发送消息给浏览器。

​		为什么传统的HTTP协议不能做到 WebSocket实现的功能?这是因为HTTP协议是ー个请求-响应协议，请求必须先由浏览器发给服务器服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。

​		现在，很多网站为了实现[推送技术](https://baike.baidu.com/item/推送技术)，所用的技术都是[轮询](https://baike.baidu.com/item/轮询)。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的[头部](https://baike.baidu.com/item/头部)，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

​		而比较新的技术去做轮询的效果是[Comet](https://baike.baidu.com/item/Comet) （曾经使用过基于Comet架构的一款叫Pushlet的框架）。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在Comet中，普遍采用的长链接，也会消耗服务器资源。

​		Comet.本质上也是轮询，但是在没有消息的情况下，服务器先拖一段时间，等到有消息了再回复。这个机制暂时地解決了实时性问题，但是它带来了新的问题，以多线程模式运行的服务器会让大部分线程大部分时间都处于挂起状态，极大地浪费服务器资源。另外，一个HTTP连接在长时间没有数据传输的情况下，链路上的任何一个网关都可能关闭这个连接，而网关是我们不可控的，这就要求 Comet连接必须定期发一些ping数据表示连接正常工作"。

​		在这种情况下，[HTML5](https://baike.baidu.com/item/HTML5)定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。

### WebSocket特点

**解释**：基于TCP的全双工通信协议。

**功能**：实现了浏览器与服务器全双工通信。

**优点**：

1. 较少的控制开销。

   ​		在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。

2. 更强的实时性。

   ​		由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。

3. 保持连接状态。

   ​		与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。

4. 更好的二进制支持。

   ​		Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。

5. 可以支持扩展。

   ​		Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。

6. 更好的压缩效果。

   ​		相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。

### 握手协议

​		WebSocket 是独立的、创建在 TCP 上的协议。
​		Websocket 通过HTTP/1.1 协议的**101状态码**进行握手。
​		为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手”（handshaking）。

![webSocket通信示意图](.\img\1571294817189.png)

首先，WebSocket连接必须由浏览器发起的，因为请求协议是一个标准的HTTP请求，格式如下：

![1571294954973](.\img\1571294954973.png)

该请求头和普通的HTTP请求有几点不同：

1. GET请求的地址不是类似 http:// ，而是 ws:// 开头的地址；
2. 请求头Connection: Upgrade 和请求头 Upgrade: websocket 表示这个连接将要被转换为 WebSocket连接；
3. Sec-WebSocket-Key 是用于标识这个连接，是一个BASE64编码的密文，要求服务端响应一个对应的加密Sec-WebSocket-Accept头信息作为应答；
4. Sec-WebSocket-Version 指定了WebScoket的协议版本；
5. HTTP 101 状态码表明服务端已经识别并切换了WebSocket协议，Sec-WebSocket-Accept是服务端与客户端一致的密钥计算出来的信息。

## Tomcat的Websocket

​		Tomcat的7.0.5版本开始支持WebSocket，并且实现了Java WebSocket规范（JSR356），而在7.0.5版本之前(7.0.2之后)则采用自定义API，即WebSocketServlet实现。

​		Java Websocket应用由一系列的WebSocketEndpoint组成。Endpoint是一个java对象，代表WebSocket链接的一端，对于服务端，我们可以视为处理具体WebSocket消息的接口，就像Servlet之http请求一样。

我们可以通过两种方式定义Endpoint：

1. 编程式，即继承类 javax.websocket.Endpoint 并实现其方法。
2. 注解式，即定义一个POJO，并添加 @ServerEndpoint 相关注解。

​		Endpoint实例在WebSocket握手时创建，并在客户端与服务器连接过程中有效，最后在连接关闭时结束。在Endpoint接口中明确定义了其生命周期相关方法，规范实现者确保生命周期的各个阶段调用实例的相关方法。生命周期方法如下：

| 方法    |          | 含义描述                                                     |
| ------- | -------- | ------------------------------------------------------------ |
| onOpen  | @OnOpen  | 当开启一个新的会话时调用，该方法是客户端与服务端握手成功后调用的方法 |
| onClose | @OnClose | 当会话关闭时调用                                             |
| onError | @OnError | 当连接过程中异常时调用                                       |

​		通过为Session添加MessageHandler消息处理器来接收消息，当采用注解方式定义Endpoint时，我们还可以通过@OnMessage注解指定接收消息的方法。发送消息则由RemoteEndpoint完成，其实例由Session维护，根据使用情况，我们可以通过Session.getBasicRemote获取同步消息发送的实例，然后调用其sendXxx()方法就可以发送消息，可以通过Session.getAsyncRemote获取异步消息发送实例。
