数据结构和算法绪论

[各种数据结构可视化操作](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

# 参考资料

【C语言描述】《数据结构和算法》（小甲鱼）99集：推荐学习-《推荐》 [地址](https://www.bilibili.com/video/av21828275/)

【青岛大学-王卓】数据结构与算法基础（40个小时） 173集：推荐学习-《推荐》 [地址](https://www.bilibili.com/video/av82837069?from=search&seid=16668239479775468624)

[他人的学习笔记](https://blog.csdn.net/liu17234050/article/details/104237990#t0)

## 什么是数据结构

​	数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关亲和操作等相关问题的学科。

​	程序设计 =  数据结构 + 算法

​	再简单的来说数据结构就是关系，就是数据元素之间存在的一种或多种特定的关系的集合，集合结构、线性结构、树形结构、图形结构等等。

## 累加问题

1. ​	**从1+2+3+4+....n，从1一直累加到n，它的结果是多少？**


如果没有算法基础，可能就只有从1老老实实的累加的n，这样的效率是n。

如果使用[高斯]()算法: result=(1+n)*n/2，时间复杂度为1。

其实上面的算法是可以通过等差数列来推导的。

2. ​	**举一反三，如果从m一直累加到n，每次加1，它的结果是多少？**

   ```tex
   算法 = (1+n)*n/2 - (1+m)*m/2 = ((1+n)*n - (1+m)*m)/2
   ```

## 算法的特性

​	算法的5个基本特征：输入、输出、有穷性、确定性和可行性。

- 输入

​	算法具有零个或多个输入。

- 输出

​	算法至少有一个或多个输出。（注意区分不一定就是指的函数的返回）

- 有穷性

​	指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。

- 确定性

  - 算法的每一个步骤都有具有确定的含义，不会出现二义性（无歧义）。

  - 算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果。

- 可行性

  算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。

## 算法的基本要求

- 正确性

  ​	指算法至少应该具有输入、输出和加工处理无歧义、能够正确反应问题的需求、能够得到问题的正确答案。

  大体分为以下4个层次：

  1. 算法程序没有语法错误；
  2. 算法程序对于合法输入能够产生满足要求的输出；
  3. 算法程序对于非法输入能够产生满足规格的说明；
  4. 算法程序对于故意刁难的测试输入都有满足要求的输出结果。

- 可读性

  算法设计另一目的是为了便于阅读、理解和交流。

- 健壮性

  当输入入数据不合法,算法也能做出相关处理,而不是产生异常、崩溃或莫名其妙的结果。

- 时间复杂度

  算法程序时间效率高。

- 空间复杂度

  算法程序存储量低。



## 时间复杂度

### 分析理解时间复杂度

拿累加问题来举例:

**第一种算法**

```c
int i, sum = 0, n = 100;// 执行1次
for (i = 1; i <= n; i++) {// 执行了n + 1次
    sum = sum + i; // 执行n次
}
```

执行了1+(n+1)+n = 2n+2次。

**第二种算法**

```c
int sum = 0, n = 100; // 执行了1次
sum = (1+n)*n/2; // 执行了1次
```

执行了1+1=2次

​     如果非常较真的研究总共精确执行了多少次是非常累的，另一方面，我们研究算法的复杂度，侧重的是研究算法随着输入规模扩大增长量的一个抽象，而不是精确地定位需要执行多少次，因为如果这样的话，我们就又得考虑回编译器优化等问题，然后就永远没有然后了。

​     这样，不计那些循环索引的递增和循环终止条件变量声明、打印结果等操作。最终,在分析程序的送行间时,最重要的是把程序看成是独立于程序设计语言的算法或一条列步骤。

​	我们在分析一个算法的运行时间时，重要的是把基本操作的数量和输入模式关联起来。

![1569740089249](.\img\1569740089249.png)

函数的渐进增长

| 规模  | 算法A1(2n+3) | 算法A2（2n） | 算法B1（3n+1） | 算法B2 （3n） |
| ----- | ------------ | ------------ | -------------- | ------------- |
| n=1   | 5            | 2            | 4              | 3             |
| n=2   | 7            | 4            | 7              | 6             |
| n=3   | 9            | 6            | 10             | 9             |
| n=10  | 23           | 20           | 31             | 30            |
| n=100 | 203          | 200          | 301            | 300           |

- 当n=1时，算法A1效率不如算法B1，当n=2时，两者效率相同；当n>2时，算法A1就开始优于算法B1了，随着n的继续增加，算法A1比算法B1逐步拉大差距。所以总体上算法A1比算法B1优秀。

  

![1569745874920](.\img\1569745874920.png)

函数的渐进增长：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们f(n)的增长渐进快于g(n)。

从上图可以看出，随着n的增大，后面的+3和+1其实是不影响最终的算法变化曲线的。

O()来体现算法时间复杂度的记法，我们称之为大O记法。 

T(n)是关于问题规模n的函数。

一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。

### **如何推导大O阶：**

- 用常数1取代运行时间中的所有加法常数；
- 在修改后的运行次数函数中，只保留最高阶项；
- 如果最高阶存在且不是1，则去除与这个项相乘的常数。

### 常见的时间复杂度

| 时间复杂度 | 术语    |
| ---------- | ------- |
| O(1)       | 常熟阶  |
| O(n)       | 线性阶  |
| O(n^2)     | 平方阶  |
| O(log(n))  | 对数阶  |
| O(nlog(n)) | nlogn阶 |
| O(n^3)     | 立方阶  |
| O(2^n)     | 指数阶  |

常用的时间复杂度所耗费的时间从小到大依次是：

O(1) < O(logn) < O(n) < O(logn) < O(nlogn) < O(n^2)  < O(n^3) < O(2^n) <  < O(n!) < O(n^n)

### 最坏情况与最坏情况

​		算法的分析也是类似,我们查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么算法的间复杂度为O(1)，但也有可能这个数字就在最后一个位置，那么间复杂度为O(n)。

​		平均运行时间是期望的运行时间。

​		最坏运行时间是一种保证。在应用中，这是一种最重要的需求，通常除非特别指定，我们提到的运行时间都是最坏情况的运行时间。

## 空间复杂度

​		算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。

